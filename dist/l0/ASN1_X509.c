/* Automatically generated by the Kremlin tool */



#include "internal/ASN1_X509.h"

#include "internal/Hacl_Lib.h"

uint32_t
serialize32_flbytes32_backwards(uint32_t len, FStar_Bytes_bytes x, uint8_t *b, uint32_t pos)
{
  uint32_t bi = 0U;
  uint32_t len1 = len - 0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len1)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(x, 0U + i);
      b[pos - len + i] = x1;
      uint32_t i_ = i + 1U;
      bi = i_;
      ite = i_ == len1;
    }
    if (ite)
    {
      break;
    }
  }
  return len;
}

uint32_t len_of_asn1_length(uint32_t len)
{
  if (len < 128U)
  {
    return 1U;
  }
  if (len < 256U)
  {
    return 2U;
  }
  if (len < 65536U)
  {
    return 3U;
  }
  if (len < 16777216U)
  {
    return 4U;
  }
  return 5U;
}

static uint32_t serialize32_asn1_length(uint32_t y_, uint8_t *b, uint32_t pos)
{
  uint8_t x;
  if (y_ < 128U)
  {
    x = (uint8_t)y_;
  }
  else
  {
    uint8_t len_len;
    if (y_ < 256U)
    {
      len_len = 1U;
    }
    else if (y_ < 65536U)
    {
      len_len = 2U;
    }
    else if (y_ < 16777216U)
    {
      len_len = 3U;
    }
    else
    {
      len_len = 4U;
    }
    x = 128U + (uint32_t)len_len;
  }
  if (x < 128U)
  {
    b[pos] = x;
    return 1U;
  }
  if (x == 129U)
  {
    b[pos] = x;
    b[pos + 1U] = (uint8_t)y_;
    return 2U;
  }
  if (x == 130U)
  {
    b[pos] = x;
    uint16_t v_ = (uint16_t)y_;
    uint32_t x1 = pos + 1U;
    store16_be(b + x1, v_);
    KRML_HOST_IGNORE(2U);
    return 3U;
  }
  if (x == 131U)
  {
    b[pos] = x;
    uint8_t lo = (uint8_t)y_;
    b[pos + 1U + 2U] = lo;
    uint32_t hi_ = y_ >> 8U;
    uint16_t hi = (uint16_t)hi_;
    uint32_t x1 = pos + 1U;
    store16_be(b + x1, hi);
    KRML_HOST_IGNORE(3U);
    return 4U;
  }
  b[pos] = x;
  uint32_t x1 = pos + 1U;
  store32_be(b + x1, y_);
  KRML_HOST_IGNORE(4U);
  return 5U;
}

static uint32_t serialize32_asn1_length_of_type(uint32_t y_, uint8_t *b, uint32_t pos)
{
  uint8_t x;
  if (y_ < 128U)
  {
    x = (uint8_t)y_;
  }
  else
  {
    uint8_t len_len;
    if (y_ < 256U)
    {
      len_len = 1U;
    }
    else if (y_ < 65536U)
    {
      len_len = 2U;
    }
    else if (y_ < 16777216U)
    {
      len_len = 3U;
    }
    else
    {
      len_len = 4U;
    }
    x = 128U + (uint32_t)len_len;
  }
  if (x < 128U)
  {
    b[pos] = x;
    return 1U;
  }
  if (x == 129U)
  {
    b[pos] = x;
    b[pos + 1U] = (uint8_t)y_;
    return 2U;
  }
  if (x == 130U)
  {
    b[pos] = x;
    uint16_t v_ = (uint16_t)y_;
    uint32_t x1 = pos + 1U;
    store16_be(b + x1, v_);
    KRML_HOST_IGNORE(2U);
    return 3U;
  }
  if (x == 131U)
  {
    b[pos] = x;
    uint8_t lo = (uint8_t)y_;
    b[pos + 1U + 2U] = lo;
    uint32_t hi_ = y_ >> 8U;
    uint16_t hi = (uint16_t)hi_;
    uint32_t x1 = pos + 1U;
    store16_be(b + x1, hi);
    KRML_HOST_IGNORE(3U);
    return 4U;
  }
  b[pos] = x;
  uint32_t x1 = pos + 1U;
  store32_be(b + x1, y_);
  KRML_HOST_IGNORE(4U);
  return 5U;
}

uint32_t
serialize32_asn1_length_of_type_backwards(
  asn1_tag_t _a,
  uint32_t len,
  uint8_t *b,
  uint32_t pos
)
{
  KRML_MAYBE_UNUSED_VAR(_a);
  uint32_t offset = len_of_asn1_length(len);
  uint32_t offset1 = serialize32_asn1_length_of_type(len, b, pos - offset);
  return offset1;
}

uint8_t encode_asn1_tag(asn1_tag_t a)
{
  if (a.tag == BOOLEAN)
  {
    return 0x01U;
  }
  if (a.tag == INTEGER)
  {
    return 0x02U;
  }
  if (a.tag == BIT_STRING)
  {
    return 0x03U;
  }
  if (a.tag == OCTET_STRING)
  {
    return 0x04U;
  }
  if (a.tag == PRINTABLE_STRING)
  {
    return 0x13U;
  }
  if (a.tag == IA5_STRING)
  {
    return 0x16U;
  }
  if (a.tag == ASN1_NULL)
  {
    return 0x05U;
  }
  if (a.tag == OID)
  {
    return 0x06U;
  }
  if (a.tag == UTC_TIME)
  {
    return 0x17U;
  }
  if (a.tag == Generalized_Time)
  {
    return 0x18U;
  }
  if (a.tag == SEQUENCE)
  {
    return 0x30U;
  }
  if (a.tag == SET)
  {
    return 0x31U;
  }
  if (a.tag == CUSTOM_TAG)
  {
    uint8_t tag_value = a.tag_value;
    asn1_tag_form_t tag_form = a.tag_form;
    asn1_tag_class_t tag_class = a.tag_class;
    uint8_t b_tag_class;
    switch (tag_class)
    {
      case APPLICATION:
        {
          b_tag_class = 0b01000000U;
          break;
        }
      case CONTEXT_SPECIFIC:
        {
          b_tag_class = 0b10000000U;
          break;
        }
      case PRIVATE:
        {
          b_tag_class = 0b11000000U;
          break;
        }
      default:
        {
          KRML_HOST_EPRINTF("KaRaMeL incomplete match at %s:%d\n", __FILE__, __LINE__);
          KRML_HOST_EXIT(253U);
        }
    }
    uint8_t b_tag_form;
    switch (tag_form)
    {
      case PRIMITIVE:
        {
          b_tag_form = 0b000000U;
          break;
        }
      case CONSTRUCTED:
        {
          b_tag_form = 0b100000U;
          break;
        }
      default:
        {
          KRML_HOST_EPRINTF("KaRaMeL incomplete match at %s:%d\n", __FILE__, __LINE__);
          KRML_HOST_EXIT(253U);
        }
    }
    return (uint32_t)b_tag_class + (uint32_t)b_tag_form + (uint32_t)tag_value;
  }
  KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
    __FILE__,
    __LINE__,
    "unreachable (pattern matches are exhaustive in F*)");
  KRML_HOST_EXIT(255U);
}

static uint32_t
serialize32_asn1_generalized_time_backwards(FStar_Bytes_bytes x, uint8_t *input, uint32_t pos)
{
  return serialize32_flbytes32_backwards(15U, x, input, pos);
}

static uint32_t
serialize32_asn1_generalized_time_TLV_backwards(FStar_Bytes_bytes x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data = serialize32_asn1_generalized_time_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = Generalized_Time }),
      15U,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - 1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = Generalized_Time }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

static uint32_t
serialize32_asn1_utc_time_backwards(FStar_Bytes_bytes x, uint8_t *input, uint32_t pos)
{
  return serialize32_flbytes32_backwards(13U, x, input, pos);
}

static uint32_t
serialize32_asn1_utc_time_TLV_backwards(FStar_Bytes_bytes x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data = serialize32_asn1_utc_time_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = UTC_TIME }),
      13U,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = UTC_TIME }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

static uint8_t
oid_RIOT_as_buffer[10U] =
  { 0x2BU, 0x06U, 0x01U, 0x04U, 0x01U, 0x82U, 0x37U, 0x59U, 0x03U, 0x01U };

static uint8_t oid_AT_CN_as_buffer[3U] = { 0x55U, 0x04U, 0x03U };

static uint8_t oid_AT_COUNTRY_as_buffer[3U] = { 0x55U, 0x04U, 0x06U };

static uint8_t oid_AT_ORGANIZATION_as_buffer[3U] = { 0x55U, 0x04U, 0x0AU };

static uint8_t
oid_CLIENT_AUTH_as_buffer[8U] = { 0x2BU, 0x06U, 0x01U, 0x05U, 0x05U, 0x07U, 0x03U, 0x02U };

static uint8_t oid_AUTHORITY_KEY_IDENTIFIER_as_buffer[3U] = { 0x55U, 0x1DU, 0x23U };

static uint8_t oid_KEY_USAGE_as_buffer[3U] = { 0x55U, 0x1DU, 0x0FU };

static uint8_t oid_EXTENDED_KEY_USAGE_as_buffer[3U] = { 0x55U, 0x1DU, 0x25U };

static uint8_t oid_BASIC_CONSTRAINTS_as_buffer[3U] = { 0x55U, 0x1DU, 0x13U };

static uint8_t oid_EC_ALG_UNRESTRICTED_as_buffer[5U] = { 0x2AU, 0xceU, 0x3dU, 0x02U, 0x01U };

static uint8_t
oid_EC_GRP_SECP256R1_as_buffer[6U] = { 0x2AU, 0xceU, 0x3dU, 0x03U, 0x01U, 0x07U };

static uint8_t
oid_DIGEST_ALG_SHA256_as_buffer[9U] =
  { 0x60U, 0x86U, 0x48U, 0x01U, 0x65U, 0x03U, 0x04U, 0x02U, 0x01U };

static uint8_t oid_ED25519_as_bufffer[3U] = { 0x2BU, 0x65U, 0x70U };

static uint8_t oid_X25519_as_bufffer[3U] = { 0x2BU, 0x65U, 0x6EU };

static uint8_t
oid_PKCS9_CSR_EXT_REQ_as_buffer[9U] =
  { 0x2AU, 0x86U, 0x48U, 0x86U, 0xF7U, 0x0DU, 0x01U, 0x09U, 0x0EU };

static uint8_t *oid_buffer_of_oid(oid_t oid)
{
  switch (oid)
  {
    case OID_RIOT:
      {
        return oid_RIOT_as_buffer;
      }
    case OID_AT_CN:
      {
        return oid_AT_CN_as_buffer;
      }
    case OID_AT_COUNTRY:
      {
        return oid_AT_COUNTRY_as_buffer;
      }
    case OID_AT_ORGANIZATION:
      {
        return oid_AT_ORGANIZATION_as_buffer;
      }
    case OID_CLIENT_AUTH:
      {
        return oid_CLIENT_AUTH_as_buffer;
      }
    case OID_AUTHORITY_KEY_IDENTIFIER:
      {
        return oid_AUTHORITY_KEY_IDENTIFIER_as_buffer;
      }
    case OID_KEY_USAGE:
      {
        return oid_KEY_USAGE_as_buffer;
      }
    case OID_EXTENDED_KEY_USAGE:
      {
        return oid_EXTENDED_KEY_USAGE_as_buffer;
      }
    case OID_BASIC_CONSTRAINTS:
      {
        return oid_BASIC_CONSTRAINTS_as_buffer;
      }
    case OID_EC_ALG_UNRESTRICTED:
      {
        return oid_EC_ALG_UNRESTRICTED_as_buffer;
      }
    case OID_EC_GRP_SECP256R1:
      {
        return oid_EC_GRP_SECP256R1_as_buffer;
      }
    case OID_ED25519:
      {
        return oid_ED25519_as_bufffer;
      }
    case OID_X25519:
      {
        return oid_X25519_as_bufffer;
      }
    case OID_DIGEST_SHA256:
      {
        return oid_DIGEST_ALG_SHA256_as_buffer;
      }
    case OID_PKCS9_CSR_EXT_REQ:
      {
        return oid_PKCS9_CSR_EXT_REQ_as_buffer;
      }
    default:
      {
        KRML_HOST_EPRINTF("KaRaMeL incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

static uint32_t len_of_oid_buffer(oid_t oid)
{
  switch (oid)
  {
    case OID_RIOT:
      {
        return 10U;
      }
    case OID_AT_CN:
      {
        return 3U;
      }
    case OID_AT_COUNTRY:
      {
        return 3U;
      }
    case OID_AT_ORGANIZATION:
      {
        return 3U;
      }
    case OID_CLIENT_AUTH:
      {
        return 8U;
      }
    case OID_AUTHORITY_KEY_IDENTIFIER:
      {
        return 3U;
      }
    case OID_KEY_USAGE:
      {
        return 3U;
      }
    case OID_EXTENDED_KEY_USAGE:
      {
        return 3U;
      }
    case OID_BASIC_CONSTRAINTS:
      {
        return 3U;
      }
    case OID_EC_ALG_UNRESTRICTED:
      {
        return 5U;
      }
    case OID_EC_GRP_SECP256R1:
      {
        return 6U;
      }
    case OID_ED25519:
      {
        return 3U;
      }
    case OID_X25519:
      {
        return 3U;
      }
    case OID_DIGEST_SHA256:
      {
        return 9U;
      }
    case OID_PKCS9_CSR_EXT_REQ:
      {
        return 9U;
      }
    default:
      {
        KRML_HOST_EPRINTF("KaRaMeL incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

uint32_t serialize32_asn1_oid_TLV_backwards(oid_t x, uint8_t *b, uint32_t pos)
{
  uint8_t *oid_buffer = oid_buffer_of_oid(x);
  uint32_t offset = len_of_oid_buffer(x);
  FStar_Bytes_bytes uu____0 = FStar_Bytes_of_buffer(offset, (uint8_t *)oid_buffer);
  uint32_t bi = 0U;
  uint32_t len = offset - 0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(uu____0, 0U + i);
      b[pos - offset + i] = x1;
      uint32_t i_ = i + 1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = offset;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = OID }),
      len_of_oid_buffer(x),
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = OID }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

uint32_t serialize32_asn1_bit_string_TLV_backwards(bit_string_t x, uint8_t *b, uint32_t pos)
{
  uint8_t leading_byte = (uint8_t)x.bs_unused_bits;
  b[pos - x.bs_len] = leading_byte;
  uint32_t bi = 0U;
  uint32_t len = x.bs_len - 1U - 0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(x.bs_s, 0U + i);
      b[pos - x.bs_len + 1U + i] = x1;
      uint32_t i_ = i + 1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = x.bs_len;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = BIT_STRING }),
      x.bs_len,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = BIT_STRING }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

static uint32_t
__proj__Mkdtuple2__item___1__uint32_t_FStar_Bytes_bytes(character_string_t pair)
{
  return pair.fst;
}

uint32_t FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(character_string_t t)
{
  return __proj__Mkdtuple2__item___1__uint32_t_FStar_Bytes_bytes(t);
}

static FStar_Bytes_bytes
__proj__Mkdtuple2__item___2__uint32_t_FStar_Bytes_bytes(character_string_t pair)
{
  return pair.snd;
}

static FStar_Bytes_bytes dsnd__uint32_t_FStar_Bytes_bytes(character_string_t t)
{
  return __proj__Mkdtuple2__item___2__uint32_t_FStar_Bytes_bytes(t);
}

static uint32_t
serialize32_asn1_printable_string_TLV_with_character_bound_backwards(
  character_string_t x,
  uint8_t *input,
  uint32_t pos
)
{
  uint32_t bi = 0U;
  uint32_t len = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x) - 0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(dsnd__uint32_t_FStar_Bytes_bytes(x), 0U + i);
      input[pos - FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x) + i] = x1;
      uint32_t i_ = i + 1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = PRINTABLE_STRING }),
      FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x),
      input,
      pos - offset_data);
  input[pos - offset_data - offset2 - 1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = PRINTABLE_STRING }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

uint32_t
serialize32_asn1_octet_string_TLV_with_tag_backwards(
  asn1_tag_t a,
  octet_string_t x,
  uint8_t *b,
  uint32_t pos
)
{
  uint32_t bi = 0U;
  uint32_t len = x.len - 0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(x.s, 0U + i);
      b[pos - x.len + i] = x1;
      uint32_t i_ = i + 1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = x.len;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = OCTET_STRING }),
      x.len,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - 1U] = encode_asn1_tag(a);
  uint32_t offset1 = 1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

uint32_t len_of_asn1_integer(int32_t value)
{
  if ((int32_t)0 <= value && value <= (int32_t)0x7F)
  {
    return 1U;
  }
  if ((int32_t)0x7F < value && value <= (int32_t)0xFF)
  {
    return 2U;
  }
  if ((int32_t)0xFF < value && value <= (int32_t)0x7FFF)
  {
    return 2U;
  }
  if ((int32_t)0x7FFF < value && value <= (int32_t)0xFFFF)
  {
    return 3U;
  }
  if ((int32_t)0xFFFF < value && value <= (int32_t)0x7FFFFF)
  {
    return 3U;
  }
  if ((int32_t)0x7FFFFF < value && value <= (int32_t)0xFFFFFF)
  {
    return 4U;
  }
  return 4U;
}

uint32_t serialize32_asn1_integer_TLV_backwards(int32_t x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data;
  if ((int32_t)0 <= x && x <= (int32_t)0x7F)
  {
    uint8_t b0 = (uint8_t)x;
    b[pos - 1U] = b0;
    offset_data = 1U;
  }
  else if ((int32_t)0x7F < x && x <= (int32_t)0xFF)
  {
    b[pos - 2U] = 0x00U;
    uint8_t b0 = (uint8_t)x;
    b[pos - 1U] = b0;
    offset_data = 2U;
  }
  else if ((int32_t)0xFF < x && x <= (int32_t)0x7FFF)
  {
    uint32_t x1 = pos - 2U;
    store16_be(b + x1, (uint16_t)x);
    offset_data = 2U;
  }
  else if ((int32_t)0x7FFF < x && x <= (int32_t)0xFFFF)
  {
    b[pos - 3U] = 0x00U;
    uint32_t x1 = pos - 2U;
    store16_be(b + x1, (uint16_t)x);
    offset_data = 3U;
  }
  else if ((int32_t)0xFFFF < x && x <= (int32_t)0x7FFFFF)
  {
    uint16_t first_2_bytes = (uint16_t)(x / (int32_t)0x100);
    uint32_t x1 = pos - 3U;
    store16_be(b + x1, first_2_bytes);
    uint8_t last_byte = (uint8_t)(x % (int32_t)0x100);
    b[pos - 1U] = last_byte;
    offset_data = 3U;
  }
  else if ((int32_t)0x7FFFFF < x && x <= (int32_t)0xFFFFFF)
  {
    b[pos - 4U] = 0x00U;
    uint16_t first_2_bytes = (uint16_t)(x / (int32_t)0x100);
    uint32_t x1 = pos - 3U;
    store16_be(b + x1, first_2_bytes);
    uint8_t last_byte = (uint8_t)(x % (int32_t)0x100);
    b[pos - 1U] = last_byte;
    offset_data = 4U;
  }
  else if ((int32_t)0xFFFFFF < x && x <= (int32_t)0x7FFFFFFF)
  {
    uint32_t value_of_all_4_bytes = (uint32_t)x;
    uint32_t x1 = pos - 4U;
    store32_be(b + x1, value_of_all_4_bytes);
    offset_data = 4U;
  }
  else
  {
    offset_data = KRML_EABORT(uint32_t, "Error: Statically unreachable.");
  }
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = INTEGER }),
      len_of_asn1_integer(x),
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = INTEGER }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

uint32_t serialize32_asn1_boolean_TLV_backwards(bool x, uint8_t *input, uint32_t pos)
{
  uint32_t offset = 1U;
  uint8_t content;
  if (x)
  {
    content = 0xFFU;
  }
  else
  {
    content = 0x00U;
  }
  input[pos - offset] = content;
  uint32_t offset2 = offset;
  uint32_t
  offset21 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = BOOLEAN }),
      1U,
      input,
      pos - offset2);
  input[pos - offset2 - offset21 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = BOOLEAN }));
  uint32_t offset1 = 1U;
  uint32_t offset10 = offset1 + offset21;
  return offset10 + offset2;
}

uint32_t serialize32_asn1_boolean_TLV_false_backwards(bool x, uint8_t *input, uint32_t pos)
{
  return serialize32_asn1_boolean_TLV_backwards(x, input, pos);
}

static uint32_t len_of_big_integer_as_octet_string(octet_string_t x)
{
  if (FStar_Bytes_get(x.s, 0U) >= 0x80U)
  {
    return x.len + 1U;
  }
  return x.len;
}

static uint32_t len_of_big_integer_as_octet_string_TLV(octet_string_t x)
{
  uint32_t len = len_of_big_integer_as_octet_string(x);
  return 1U + len_of_asn1_length(len) + len;
}

static uint32_t
serialize32_asn1_length_of_big_integer_backwards(uint32_t len, uint8_t *b, uint32_t pos)
{
  uint32_t offset = len_of_asn1_length(len);
  uint32_t offset1 = serialize32_asn1_length(len, b, pos - offset);
  return offset1;
}

static uint32_t
serialize32_big_integer_as_octet_string_TLV_backwards(
  octet_string_t x,
  uint8_t *b,
  uint32_t pos
)
{
  uint32_t bi = 0U;
  uint32_t len = x.len - 0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(x.s, 0U + i);
      b[pos - x.len + i] = x1;
      uint32_t i_ = i + 1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  if (FStar_Bytes_get(x.s, 0U) >= 0x80U)
  {
    b[pos - len_of_big_integer_as_octet_string(x)] = 0x00U;
  }
  uint32_t offset_data = len_of_big_integer_as_octet_string(x);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_big_integer_backwards(len_of_big_integer_as_octet_string(x),
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = INTEGER }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

asn1_tag_t
x509_authKeyID_keyIdentifier_tag =
  { .tag = CUSTOM_TAG, .tag_class = CONTEXT_SPECIFIC, .tag_form = PRIMITIVE, .tag_value = 0U };

static bit_string_t _synth_x509_key_usage_payload_inverse_impl(int32_t ku)
{
  uint8_t b0 = (uint8_t)(ku % (int32_t)0x100);
  uint8_t b1 = (uint8_t)(ku / (int32_t)0x100);
  FStar_Bytes_bytes
  s32 = FStar_Bytes_append(FStar_Bytes_create(1U, b0), FStar_Bytes_create(1U, b1));
  return ((bit_string_t){ .bs_len = 3U, .bs_unused_bits = 7U, .bs_s = s32 });
}

static uint32_t
_serialize32_x509_key_usage_payload_backwards(int32_t x, uint8_t *input, uint32_t pos)
{
  return
    serialize32_asn1_bit_string_TLV_backwards(_synth_x509_key_usage_payload_inverse_impl(x),
      input,
      pos);
}

uint32_t serialize32_x509_key_usage_backwards(key_usage_t x, uint8_t *b, uint32_t pos)
{
  oid_t x1 = x.fst;
  int32_t x2 = x.snd;
  uint32_t offset_data = _serialize32_x509_key_usage_payload_backwards(x2, b, pos);
  uint32_t
  offset20 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = OCTET_STRING }),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset20 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = OCTET_STRING }));
  uint32_t offset10 = 1U;
  uint32_t offset_tag_len = offset10 + offset20;
  uint32_t offset21 = offset_tag_len + offset_data;
  uint32_t offset11 = serialize32_asn1_oid_TLV_backwards(x1, b, pos - offset21);
  uint32_t offset_data0 = offset11 + offset21;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data0,
      b,
      pos - offset_data0);
  b[pos - offset_data0 - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag_len0 = offset1 + offset2;
  return offset_tag_len0 + offset_data0;
}

uint32_t
serialize32_RDN_COMMON_NAME(
  K___ASN1_Base_oid_t_ASN1_Base_character_string_t x,
  uint8_t *b,
  uint32_t pos
)
{
  oid_t x1 = x.fst;
  character_string_t x2 = x.snd;
  uint32_t bi = 0U;
  uint32_t len = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2) - 0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x3 = FStar_Bytes_get(dsnd__uint32_t_FStar_Bytes_bytes(x2), 0U + i);
      b[pos - FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2) + i] = x3;
      uint32_t i_ = i + 1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2);
  uint32_t
  offset20 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = IA5_STRING }),
      FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2),
      b,
      pos - offset_data);
  b[pos - offset_data - offset20 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = IA5_STRING }));
  uint32_t offset10 = 1U;
  uint32_t offset_tag = offset10 + offset20;
  uint32_t offset21 = offset_tag + offset_data;
  uint32_t offset11 = serialize32_asn1_oid_TLV_backwards(x1, b, pos - offset21);
  uint32_t offset_data0 = offset11 + offset21;
  uint32_t
  offset22 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data0,
      b,
      pos - offset_data0);
  b[pos - offset_data0 - offset22 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset12 = 1U;
  uint32_t offset_tag_len = offset12 + offset22;
  uint32_t offset_data1 = offset_tag_len + offset_data0;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SET }),
      offset_data1,
      b,
      pos - offset_data1);
  b[pos - offset_data1 - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SET }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag_len0 = offset1 + offset2;
  return offset_tag_len0 + offset_data1;
}

uint32_t
serialize32_RDN_ORGANIZATION(
  K___ASN1_Base_oid_t_ASN1_Base_character_string_t x,
  uint8_t *b,
  uint32_t pos
)
{
  oid_t x1 = x.fst;
  character_string_t x2 = x.snd;
  uint32_t bi = 0U;
  uint32_t len = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2) - 0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x3 = FStar_Bytes_get(dsnd__uint32_t_FStar_Bytes_bytes(x2), 0U + i);
      b[pos - FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2) + i] = x3;
      uint32_t i_ = i + 1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2);
  uint32_t
  offset20 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = IA5_STRING }),
      FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2),
      b,
      pos - offset_data);
  b[pos - offset_data - offset20 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = IA5_STRING }));
  uint32_t offset10 = 1U;
  uint32_t offset_tag = offset10 + offset20;
  uint32_t offset21 = offset_tag + offset_data;
  uint32_t offset11 = serialize32_asn1_oid_TLV_backwards(x1, b, pos - offset21);
  uint32_t offset_data0 = offset11 + offset21;
  uint32_t
  offset22 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data0,
      b,
      pos - offset_data0);
  b[pos - offset_data0 - offset22 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset12 = 1U;
  uint32_t offset_tag_len = offset12 + offset22;
  uint32_t offset_data1 = offset_tag_len + offset_data0;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SET }),
      offset_data1,
      b,
      pos - offset_data1);
  b[pos - offset_data1 - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SET }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag_len0 = offset1 + offset2;
  return offset_tag_len0 + offset_data1;
}

uint32_t
serialize32_RDN_COUNTRY(
  K___ASN1_Base_oid_t_ASN1_Base_character_string_t x,
  uint8_t *b,
  uint32_t pos
)
{
  oid_t x1 = x.fst;
  character_string_t x2 = x.snd;
  uint32_t
  offset20 = serialize32_asn1_printable_string_TLV_with_character_bound_backwards(x2, b, pos);
  uint32_t offset10 = serialize32_asn1_oid_TLV_backwards(x1, b, pos - offset20);
  uint32_t offset_data = offset10 + offset20;
  uint32_t
  offset21 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset21 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset11 = 1U;
  uint32_t offset_tag_len = offset11 + offset21;
  uint32_t offset_data0 = offset_tag_len + offset_data;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SET }),
      offset_data0,
      b,
      pos - offset_data0);
  b[pos - offset_data0 - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SET }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag_len0 = offset1 + offset2;
  return offset_tag_len0 + offset_data0;
}

asn1_tag_t
x509_extensions_outmost_explicit_tag =
  { .tag = CUSTOM_TAG, .tag_class = CONTEXT_SPECIFIC, .tag_form = CONSTRUCTED, .tag_value = 3U };

uint32_t len_of_x509_extensions(uint32_t len_payload)
{
  return 1U + len_of_asn1_length(len_payload) + len_payload;
}

uint8_t
x509_validity_notBefore_default_buffer[13U] =
  { 0x31U, 0x37U, 0x30U, 0x31U, 0x30U, 0x31U, 0x30U, 0x30U, 0x30U, 0x30U, 0x30U, 0x30U, 0x5AU };

uint8_t
x509_validity_notAfter_default_buffer[15U] =
  {
    0x39U, 0x39U, 0x39U, 0x39U, 0x31U, 0x32U, 0x33U, 0x31U, 0x32U, 0x33U, 0x35U, 0x39U, 0x35U,
    0x39U, 0x5AU
  };

static uint32_t
serialize32_x509_validity_payload_backwards(
  x509_validity_payload_t x,
  uint8_t *input,
  uint32_t pos
)
{
  uint32_t offset2 = serialize32_asn1_generalized_time_TLV_backwards(x.notAfter, input, pos);
  uint32_t offset1 = serialize32_asn1_utc_time_TLV_backwards(x.notBefore, input, pos - offset2);
  return offset1 + offset2;
}

uint32_t
serialize32_x509_validity_backwards(x509_validity_payload_t x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data = serialize32_x509_validity_payload_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag_len = offset1 + offset2;
  return offset_tag_len + offset_data;
}

typedef oid_t algorithmIdentifier_Ed25519_t;

static uint32_t
serialize32_algorithmIdentifier_payload_backwards(oid_t x, uint8_t *input, uint32_t pos)
{
  return serialize32_asn1_oid_TLV_backwards(x, input, pos);
}

uint32_t serialize32_algorithmIdentifier_backwards(oid_t x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data = serialize32_algorithmIdentifier_payload_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag_len = offset1 + offset2;
  return offset_tag_len + offset_data;
}

static uint32_t
serialize32_subjectPublicKeyInfo_payload_backwards(
  subjectPublicKeyInfo_payload_t x,
  uint8_t *input,
  uint32_t pos
)
{
  uint32_t offset2 = serialize32_asn1_bit_string_TLV_backwards(x.subjectPubKey, input, pos);
  uint32_t
  offset1 = serialize32_algorithmIdentifier_backwards(x.subjectPubKey_alg, input, pos - offset2);
  return offset1 + offset2;
}

uint32_t
serialize32_subjectPublicKeyInfo_backwards(
  subjectPublicKeyInfo_payload_t x,
  uint8_t *b,
  uint32_t pos
)
{
  uint32_t offset_data = serialize32_subjectPublicKeyInfo_payload_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - 1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset1 = 1U;
  uint32_t offset_tag_len = offset1 + offset2;
  return offset_tag_len + offset_data;
}

subjectPublicKeyInfo_payload_t x509_get_subjectPublicKeyInfo(FStar_Bytes_bytes pubkey)
{
  bit_string_t pubkey_bs = { .bs_len = 33U, .bs_unused_bits = 0U, .bs_s = pubkey };
  oid_t alg_id = OID_ED25519;
  return
    ((subjectPublicKeyInfo_payload_t){ .subjectPubKey_alg = alg_id, .subjectPubKey = pubkey_bs });
}

uint32_t len_of_x509_serialNumber(octet_string_t x)
{
  return len_of_big_integer_as_octet_string_TLV(x);
}

uint32_t
serialize32_x509_serialNumber_backwards(octet_string_t x, uint8_t *input, uint32_t pos)
{
  return serialize32_big_integer_as_octet_string_TLV_backwards(x, input, pos);
}

static uint32_t
serialize32_x509_version_payload_backwards(int32_t x, uint8_t *input, uint32_t pos)
{
  return serialize32_asn1_integer_TLV_backwards(x, input, pos);
}

uint32_t serialize32_x509_version_backwards(int32_t x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data = serialize32_x509_version_payload_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards((
        (asn1_tag_t){
          .tag = CUSTOM_TAG,
          .tag_class = CONTEXT_SPECIFIC,
          .tag_form = CONSTRUCTED,
          .tag_value = 0U
        }
      ),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - 1U] =
    encode_asn1_tag((
        (asn1_tag_t){
          .tag = CUSTOM_TAG,
          .tag_class = CONTEXT_SPECIFIC,
          .tag_form = CONSTRUCTED,
          .tag_value = 0U
        }
      ));
  uint32_t offset1 = 1U;
  uint32_t offset_tag_len = offset1 + offset2;
  return offset_tag_len + offset_data;
}

