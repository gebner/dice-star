/* Automatically generated by the Kremlin tool */



#include "ASN1_X509.h"

uint32_t
serialize32_flbytes32_backwards(uint32_t len, FStar_Bytes_bytes x, uint8_t *b, uint32_t pos)
{
  uint32_t bi = (uint32_t)0U;
  uint32_t len1 = len - (uint32_t)0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len1)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(x, (uint32_t)0U + i);
      b[pos - len + i] = x1;
      uint32_t i_ = i + (uint32_t)1U;
      bi = i_;
      ite = i_ == len1;
    }
    if (ite)
    {
      break;
    }
  }
  return len;
}

uint32_t len_of_asn1_length(uint32_t len)
{
  if (len < (uint32_t)128U)
  {
    return (uint32_t)1U;
  }
  if (len < (uint32_t)256U)
  {
    return (uint32_t)2U;
  }
  if (len < (uint32_t)65536U)
  {
    return (uint32_t)3U;
  }
  if (len < (uint32_t)16777216U)
  {
    return (uint32_t)4U;
  }
  return (uint32_t)5U;
}

static uint32_t serialize32_asn1_length(uint32_t y_, uint8_t *b, uint32_t pos)
{
  uint8_t x;
  if (y_ < (uint32_t)128U)
  {
    x = (uint8_t)y_;
  }
  else
  {
    uint8_t len_len;
    if (y_ < (uint32_t)256U)
    {
      len_len = (uint8_t)1U;
    }
    else if (y_ < (uint32_t)65536U)
    {
      len_len = (uint8_t)2U;
    }
    else if (y_ < (uint32_t)16777216U)
    {
      len_len = (uint8_t)3U;
    }
    else
    {
      len_len = (uint8_t)4U;
    }
    x = (uint8_t)128U + len_len;
  }
  if (x < (uint8_t)128U)
  {
    b[pos] = x;
    return (uint32_t)1U;
  }
  if (x == (uint8_t)129U)
  {
    b[pos] = x;
    b[pos + (uint32_t)1U] = (uint8_t)y_;
    return (uint32_t)2U;
  }
  if (x == (uint8_t)130U)
  {
    b[pos] = x;
    uint16_t v_ = (uint16_t)y_;
    uint32_t x1 = pos + (uint32_t)1U;
    store16_be(b + x1, v_);
    uint32_t z = (uint32_t)2U;
    return (uint32_t)3U;
  }
  if (x == (uint8_t)131U)
  {
    b[pos] = x;
    uint8_t lo = (uint8_t)y_;
    b[pos + (uint32_t)1U + (uint32_t)2U] = lo;
    uint32_t hi_ = y_ >> (uint32_t)8U;
    uint16_t hi = (uint16_t)hi_;
    uint32_t x1 = pos + (uint32_t)1U;
    store16_be(b + x1, hi);
    uint32_t z = (uint32_t)3U;
    return (uint32_t)4U;
  }
  b[pos] = x;
  uint32_t x1 = pos + (uint32_t)1U;
  store32_be(b + x1, y_);
  uint32_t z = (uint32_t)4U;
  return (uint32_t)5U;
}

static uint32_t serialize32_asn1_length_of_type(uint32_t y_, uint8_t *b, uint32_t pos)
{
  uint8_t x;
  if (y_ < (uint32_t)128U)
  {
    x = (uint8_t)y_;
  }
  else
  {
    uint8_t len_len;
    if (y_ < (uint32_t)256U)
    {
      len_len = (uint8_t)1U;
    }
    else if (y_ < (uint32_t)65536U)
    {
      len_len = (uint8_t)2U;
    }
    else if (y_ < (uint32_t)16777216U)
    {
      len_len = (uint8_t)3U;
    }
    else
    {
      len_len = (uint8_t)4U;
    }
    x = (uint8_t)128U + len_len;
  }
  if (x < (uint8_t)128U)
  {
    b[pos] = x;
    return (uint32_t)1U;
  }
  if (x == (uint8_t)129U)
  {
    b[pos] = x;
    b[pos + (uint32_t)1U] = (uint8_t)y_;
    return (uint32_t)2U;
  }
  if (x == (uint8_t)130U)
  {
    b[pos] = x;
    uint16_t v_ = (uint16_t)y_;
    uint32_t x1 = pos + (uint32_t)1U;
    store16_be(b + x1, v_);
    uint32_t z = (uint32_t)2U;
    return (uint32_t)3U;
  }
  if (x == (uint8_t)131U)
  {
    b[pos] = x;
    uint8_t lo = (uint8_t)y_;
    b[pos + (uint32_t)1U + (uint32_t)2U] = lo;
    uint32_t hi_ = y_ >> (uint32_t)8U;
    uint16_t hi = (uint16_t)hi_;
    uint32_t x1 = pos + (uint32_t)1U;
    store16_be(b + x1, hi);
    uint32_t z = (uint32_t)3U;
    return (uint32_t)4U;
  }
  b[pos] = x;
  uint32_t x1 = pos + (uint32_t)1U;
  store32_be(b + x1, y_);
  uint32_t z = (uint32_t)4U;
  return (uint32_t)5U;
}

uint32_t
serialize32_asn1_length_of_type_backwards(
  asn1_tag_t _a,
  uint32_t len,
  uint8_t *b,
  uint32_t pos
)
{
  uint32_t offset = len_of_asn1_length(len);
  uint32_t offset1 = serialize32_asn1_length_of_type(len, b, pos - offset);
  return offset1;
}

uint8_t encode_asn1_tag(asn1_tag_t a)
{
  if (a.tag == BOOLEAN)
  {
    return (uint8_t)0x01U;
  }
  if (a.tag == INTEGER)
  {
    return (uint8_t)0x02U;
  }
  if (a.tag == BIT_STRING)
  {
    return (uint8_t)0x03U;
  }
  if (a.tag == OCTET_STRING)
  {
    return (uint8_t)0x04U;
  }
  if (a.tag == PRINTABLE_STRING)
  {
    return (uint8_t)0x13U;
  }
  if (a.tag == IA5_STRING)
  {
    return (uint8_t)0x16U;
  }
  if (a.tag == ASN1_NULL)
  {
    return (uint8_t)0x05U;
  }
  if (a.tag == OID)
  {
    return (uint8_t)0x06U;
  }
  if (a.tag == UTC_TIME)
  {
    return (uint8_t)0x17U;
  }
  if (a.tag == Generalized_Time)
  {
    return (uint8_t)0x18U;
  }
  if (a.tag == SEQUENCE)
  {
    return (uint8_t)0x30U;
  }
  if (a.tag == SET)
  {
    return (uint8_t)0x31U;
  }
  if (a.tag == CUSTOM_TAG)
  {
    uint8_t tag_value = a.tag_value;
    asn1_tag_form_t tag_form = a.tag_form;
    asn1_tag_class_t tag_class = a.tag_class;
    uint8_t b_tag_class;
    switch (tag_class)
    {
      case APPLICATION:
        {
          b_tag_class = (uint8_t)0b01000000U;
          break;
        }
      case CONTEXT_SPECIFIC:
        {
          b_tag_class = (uint8_t)0b10000000U;
          break;
        }
      case PRIVATE:
        {
          b_tag_class = (uint8_t)0b11000000U;
          break;
        }
      default:
        {
          KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
          KRML_HOST_EXIT(253U);
        }
    }
    uint8_t b_tag_form;
    switch (tag_form)
    {
      case PRIMITIVE:
        {
          b_tag_form = (uint8_t)0b000000U;
          break;
        }
      case CONSTRUCTED:
        {
          b_tag_form = (uint8_t)0b100000U;
          break;
        }
      default:
        {
          KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
          KRML_HOST_EXIT(253U);
        }
    }
    return b_tag_class + b_tag_form + tag_value;
  }
  KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
    __FILE__,
    __LINE__,
    "unreachable (pattern matches are exhaustive in F*)");
  KRML_HOST_EXIT(255U);
}

static uint32_t
serialize32_asn1_generalized_time_backwards(FStar_Bytes_bytes x, uint8_t *input, uint32_t pos)
{
  return serialize32_flbytes32_backwards((uint32_t)15U, x, input, pos);
}

static uint32_t
serialize32_asn1_generalized_time_TLV_backwards(FStar_Bytes_bytes x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data = serialize32_asn1_generalized_time_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = Generalized_Time }),
      (uint32_t)15U,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = Generalized_Time }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

static uint32_t
serialize32_asn1_utc_time_backwards(FStar_Bytes_bytes x, uint8_t *input, uint32_t pos)
{
  return serialize32_flbytes32_backwards((uint32_t)13U, x, input, pos);
}

static uint32_t
serialize32_asn1_utc_time_TLV_backwards(FStar_Bytes_bytes x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data = serialize32_asn1_utc_time_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = UTC_TIME }),
      (uint32_t)13U,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = UTC_TIME }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

static uint8_t
oid_RIOT_as_buffer[10U] =
  {
    (uint8_t)0x2BU, (uint8_t)0x06U, (uint8_t)0x01U, (uint8_t)0x04U, (uint8_t)0x01U, (uint8_t)0x82U,
    (uint8_t)0x37U, (uint8_t)0x59U, (uint8_t)0x03U, (uint8_t)0x01U
  };

static uint8_t oid_AT_CN_as_buffer[3U] = { (uint8_t)0x55U, (uint8_t)0x04U, (uint8_t)0x03U };

static uint8_t
oid_AT_COUNTRY_as_buffer[3U] = { (uint8_t)0x55U, (uint8_t)0x04U, (uint8_t)0x06U };

static uint8_t
oid_AT_ORGANIZATION_as_buffer[3U] = { (uint8_t)0x55U, (uint8_t)0x04U, (uint8_t)0x0AU };

static uint8_t
oid_CLIENT_AUTH_as_buffer[8U] =
  {
    (uint8_t)0x2BU, (uint8_t)0x06U, (uint8_t)0x01U, (uint8_t)0x05U, (uint8_t)0x05U, (uint8_t)0x07U,
    (uint8_t)0x03U, (uint8_t)0x02U
  };

static uint8_t
oid_AUTHORITY_KEY_IDENTIFIER_as_buffer[3U] = { (uint8_t)0x55U, (uint8_t)0x1DU, (uint8_t)0x23U };

static uint8_t
oid_KEY_USAGE_as_buffer[3U] = { (uint8_t)0x55U, (uint8_t)0x1DU, (uint8_t)0x0FU };

static uint8_t
oid_EXTENDED_KEY_USAGE_as_buffer[3U] = { (uint8_t)0x55U, (uint8_t)0x1DU, (uint8_t)0x25U };

static uint8_t
oid_BASIC_CONSTRAINTS_as_buffer[3U] = { (uint8_t)0x55U, (uint8_t)0x1DU, (uint8_t)0x13U };

static uint8_t
oid_EC_ALG_UNRESTRICTED_as_buffer[5U] =
  { (uint8_t)0x2AU, (uint8_t)0xceU, (uint8_t)0x3dU, (uint8_t)0x02U, (uint8_t)0x01U };

static uint8_t
oid_EC_GRP_SECP256R1_as_buffer[6U] =
  {
    (uint8_t)0x2AU, (uint8_t)0xceU, (uint8_t)0x3dU, (uint8_t)0x03U, (uint8_t)0x01U, (uint8_t)0x07U
  };

static uint8_t
oid_DIGEST_ALG_SHA256_as_buffer[9U] =
  {
    (uint8_t)0x60U, (uint8_t)0x86U, (uint8_t)0x48U, (uint8_t)0x01U, (uint8_t)0x65U, (uint8_t)0x03U,
    (uint8_t)0x04U, (uint8_t)0x02U, (uint8_t)0x01U
  };

static uint8_t oid_ED25519_as_bufffer[3U] = { (uint8_t)0x2BU, (uint8_t)0x65U, (uint8_t)0x70U };

static uint8_t oid_X25519_as_bufffer[3U] = { (uint8_t)0x2BU, (uint8_t)0x65U, (uint8_t)0x6EU };

static uint8_t
oid_PKCS9_CSR_EXT_REQ_as_buffer[9U] =
  {
    (uint8_t)0x2AU, (uint8_t)0x86U, (uint8_t)0x48U, (uint8_t)0x86U, (uint8_t)0xF7U, (uint8_t)0x0DU,
    (uint8_t)0x01U, (uint8_t)0x09U, (uint8_t)0x0EU
  };

static uint8_t *oid_buffer_of_oid(oid_t oid)
{
  switch (oid)
  {
    case OID_RIOT:
      {
        return oid_RIOT_as_buffer;
      }
    case OID_AT_CN:
      {
        return oid_AT_CN_as_buffer;
      }
    case OID_AT_COUNTRY:
      {
        return oid_AT_COUNTRY_as_buffer;
      }
    case OID_AT_ORGANIZATION:
      {
        return oid_AT_ORGANIZATION_as_buffer;
      }
    case OID_CLIENT_AUTH:
      {
        return oid_CLIENT_AUTH_as_buffer;
      }
    case OID_AUTHORITY_KEY_IDENTIFIER:
      {
        return oid_AUTHORITY_KEY_IDENTIFIER_as_buffer;
      }
    case OID_KEY_USAGE:
      {
        return oid_KEY_USAGE_as_buffer;
      }
    case OID_EXTENDED_KEY_USAGE:
      {
        return oid_EXTENDED_KEY_USAGE_as_buffer;
      }
    case OID_BASIC_CONSTRAINTS:
      {
        return oid_BASIC_CONSTRAINTS_as_buffer;
      }
    case OID_EC_ALG_UNRESTRICTED:
      {
        return oid_EC_ALG_UNRESTRICTED_as_buffer;
      }
    case OID_EC_GRP_SECP256R1:
      {
        return oid_EC_GRP_SECP256R1_as_buffer;
      }
    case OID_ED25519:
      {
        return oid_ED25519_as_bufffer;
      }
    case OID_X25519:
      {
        return oid_X25519_as_bufffer;
      }
    case OID_DIGEST_SHA256:
      {
        return oid_DIGEST_ALG_SHA256_as_buffer;
      }
    case OID_PKCS9_CSR_EXT_REQ:
      {
        return oid_PKCS9_CSR_EXT_REQ_as_buffer;
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

static uint32_t len_of_oid_buffer(oid_t oid)
{
  switch (oid)
  {
    case OID_RIOT:
      {
        return (uint32_t)10U;
      }
    case OID_AT_CN:
      {
        return (uint32_t)3U;
      }
    case OID_AT_COUNTRY:
      {
        return (uint32_t)3U;
      }
    case OID_AT_ORGANIZATION:
      {
        return (uint32_t)3U;
      }
    case OID_CLIENT_AUTH:
      {
        return (uint32_t)8U;
      }
    case OID_AUTHORITY_KEY_IDENTIFIER:
      {
        return (uint32_t)3U;
      }
    case OID_KEY_USAGE:
      {
        return (uint32_t)3U;
      }
    case OID_EXTENDED_KEY_USAGE:
      {
        return (uint32_t)3U;
      }
    case OID_BASIC_CONSTRAINTS:
      {
        return (uint32_t)3U;
      }
    case OID_EC_ALG_UNRESTRICTED:
      {
        return (uint32_t)5U;
      }
    case OID_EC_GRP_SECP256R1:
      {
        return (uint32_t)6U;
      }
    case OID_ED25519:
      {
        return (uint32_t)3U;
      }
    case OID_X25519:
      {
        return (uint32_t)3U;
      }
    case OID_DIGEST_SHA256:
      {
        return (uint32_t)9U;
      }
    case OID_PKCS9_CSR_EXT_REQ:
      {
        return (uint32_t)9U;
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

uint32_t serialize32_asn1_oid_TLV_backwards(oid_t x, uint8_t *b, uint32_t pos)
{
  uint8_t *oid_buffer = oid_buffer_of_oid(x);
  uint32_t offset = len_of_oid_buffer(x);
  FStar_Bytes_bytes uu____0 = FStar_Bytes_of_buffer(offset, (uint8_t *)oid_buffer);
  uint32_t bi = (uint32_t)0U;
  uint32_t len = offset - (uint32_t)0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(uu____0, (uint32_t)0U + i);
      b[pos - offset + i] = x1;
      uint32_t i_ = i + (uint32_t)1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = offset;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = OID }),
      len_of_oid_buffer(x),
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] = encode_asn1_tag(((asn1_tag_t){ .tag = OID }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

uint32_t serialize32_asn1_bit_string_TLV_backwards(bit_string_t x, uint8_t *b, uint32_t pos)
{
  uint8_t leading_byte = (uint8_t)x.bs_unused_bits;
  b[pos - x.bs_len] = leading_byte;
  uint32_t bi = (uint32_t)0U;
  uint32_t len = x.bs_len - (uint32_t)1U - (uint32_t)0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(x.bs_s, (uint32_t)0U + i);
      b[pos - x.bs_len + (uint32_t)1U + i] = x1;
      uint32_t i_ = i + (uint32_t)1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = x.bs_len;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = BIT_STRING }),
      x.bs_len,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = BIT_STRING }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

static uint32_t
__proj__Mkdtuple2__item___1__uint32_t_FStar_Bytes_bytes(
  Prims_dtuple2__uint32_t_FStar_Bytes_bytes pair
)
{
  return pair.fst;
}

uint32_t
FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(Prims_dtuple2__uint32_t_FStar_Bytes_bytes t)
{
  return __proj__Mkdtuple2__item___1__uint32_t_FStar_Bytes_bytes(t);
}

static FStar_Bytes_bytes
__proj__Mkdtuple2__item___2__uint32_t_FStar_Bytes_bytes(
  Prims_dtuple2__uint32_t_FStar_Bytes_bytes pair
)
{
  return pair.snd;
}

static FStar_Bytes_bytes
dsnd__uint32_t_FStar_Bytes_bytes(Prims_dtuple2__uint32_t_FStar_Bytes_bytes t)
{
  return __proj__Mkdtuple2__item___2__uint32_t_FStar_Bytes_bytes(t);
}

static uint32_t
serialize32_asn1_printable_string_TLV_with_character_bound_backwards(
  Prims_dtuple2__uint32_t_FStar_Bytes_bytes x,
  uint8_t *input,
  uint32_t pos
)
{
  uint32_t bi = (uint32_t)0U;
  uint32_t len = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x) - (uint32_t)0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(dsnd__uint32_t_FStar_Bytes_bytes(x), (uint32_t)0U + i);
      input[pos - FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x) + i] = x1;
      uint32_t i_ = i + (uint32_t)1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = PRINTABLE_STRING }),
      FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x),
      input,
      pos - offset_data);
  input[pos - offset_data - offset2 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = PRINTABLE_STRING }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

uint32_t
serialize32_asn1_octet_string_TLV_with_tag_backwards(
  asn1_tag_t a,
  octet_string_t x,
  uint8_t *b,
  uint32_t pos
)
{
  uint32_t bi = (uint32_t)0U;
  uint32_t len = x.len - (uint32_t)0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(x.s, (uint32_t)0U + i);
      b[pos - x.len + i] = x1;
      uint32_t i_ = i + (uint32_t)1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = x.len;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = OCTET_STRING }),
      x.len,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] = encode_asn1_tag(a);
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

uint32_t len_of_asn1_integer(int32_t value)
{
  if ((int32_t)0 <= value && value <= (int32_t)0x7F)
  {
    return (uint32_t)1U;
  }
  if ((int32_t)0x7F < value && value <= (int32_t)0xFF)
  {
    return (uint32_t)2U;
  }
  if ((int32_t)0xFF < value && value <= (int32_t)0x7FFF)
  {
    return (uint32_t)2U;
  }
  if ((int32_t)0x7FFF < value && value <= (int32_t)0xFFFF)
  {
    return (uint32_t)3U;
  }
  if ((int32_t)0xFFFF < value && value <= (int32_t)0x7FFFFF)
  {
    return (uint32_t)3U;
  }
  if ((int32_t)0x7FFFFF < value && value <= (int32_t)0xFFFFFF)
  {
    return (uint32_t)4U;
  }
  return (uint32_t)4U;
}

uint32_t serialize32_asn1_integer_TLV_backwards(int32_t x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data;
  if ((int32_t)0 <= x && x <= (int32_t)0x7F)
  {
    uint8_t b0 = (uint8_t)x;
    b[pos - (uint32_t)1U] = b0;
    offset_data = (uint32_t)1U;
  }
  else if ((int32_t)0x7F < x && x <= (int32_t)0xFF)
  {
    b[pos - (uint32_t)2U] = (uint8_t)0x00U;
    uint8_t b0 = (uint8_t)x;
    b[pos - (uint32_t)1U] = b0;
    offset_data = (uint32_t)2U;
  }
  else if ((int32_t)0xFF < x && x <= (int32_t)0x7FFF)
  {
    uint32_t x1 = pos - (uint32_t)2U;
    store16_be(b + x1, (uint16_t)x);
    offset_data = (uint32_t)2U;
  }
  else if ((int32_t)0x7FFF < x && x <= (int32_t)0xFFFF)
  {
    b[pos - (uint32_t)3U] = (uint8_t)0x00U;
    uint32_t x1 = pos - (uint32_t)2U;
    store16_be(b + x1, (uint16_t)x);
    offset_data = (uint32_t)3U;
  }
  else if ((int32_t)0xFFFF < x && x <= (int32_t)0x7FFFFF)
  {
    uint16_t first_2_bytes = (uint16_t)(x / (int32_t)0x100);
    uint32_t x1 = pos - (uint32_t)3U;
    store16_be(b + x1, first_2_bytes);
    uint8_t last_byte = (uint8_t)(x % (int32_t)0x100);
    b[pos - (uint32_t)1U] = last_byte;
    offset_data = (uint32_t)3U;
  }
  else if ((int32_t)0x7FFFFF < x && x <= (int32_t)0xFFFFFF)
  {
    b[pos - (uint32_t)4U] = (uint8_t)0x00U;
    uint16_t first_2_bytes = (uint16_t)(x / (int32_t)0x100);
    uint32_t x1 = pos - (uint32_t)3U;
    store16_be(b + x1, first_2_bytes);
    uint8_t last_byte = (uint8_t)(x % (int32_t)0x100);
    b[pos - (uint32_t)1U] = last_byte;
    offset_data = (uint32_t)4U;
  }
  else if ((int32_t)0xFFFFFF < x && x <= (int32_t)0x7FFFFFFF)
  {
    uint32_t value_of_all_4_bytes = (uint32_t)x;
    uint32_t x1 = pos - (uint32_t)4U;
    store32_be(b + x1, value_of_all_4_bytes);
    offset_data = (uint32_t)4U;
  }
  else
  {
    offset_data = KRML_EABORT(uint32_t, "Error: Statically unreachable.");
  }
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = INTEGER }),
      len_of_asn1_integer(x),
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = INTEGER }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

uint32_t serialize32_asn1_boolean_TLV_backwards(bool x, uint8_t *input, uint32_t pos)
{
  uint32_t offset = (uint32_t)1U;
  uint8_t content;
  if (x)
  {
    content = (uint8_t)0xFFU;
  }
  else
  {
    content = (uint8_t)0x00U;
  }
  input[pos - offset] = content;
  uint32_t offset2 = offset;
  uint32_t
  offset21 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = BOOLEAN }),
      (uint32_t)1U,
      input,
      pos - offset2);
  input[pos - offset2 - offset21 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = BOOLEAN }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset10 = offset1 + offset21;
  return offset10 + offset2;
}

uint32_t serialize32_asn1_boolean_TLV_false_backwards(bool x, uint8_t *input, uint32_t pos)
{
  return serialize32_asn1_boolean_TLV_backwards(x, input, pos);
}

static uint32_t len_of_big_integer_as_octet_string(octet_string_t x)
{
  if (FStar_Bytes_get(x.s, (uint32_t)0U) >= (uint8_t)0x80U)
  {
    return x.len + (uint32_t)1U;
  }
  return x.len;
}

static uint32_t len_of_big_integer_as_octet_string_TLV(octet_string_t x)
{
  uint32_t len = len_of_big_integer_as_octet_string(x);
  return (uint32_t)1U + len_of_asn1_length(len) + len;
}

static uint32_t
serialize32_asn1_length_of_big_integer_backwards(uint32_t len, uint8_t *b, uint32_t pos)
{
  uint32_t offset = len_of_asn1_length(len);
  uint32_t offset1 = serialize32_asn1_length(len, b, pos - offset);
  return offset1;
}

static uint32_t
serialize32_big_integer_as_octet_string_TLV_backwards(
  octet_string_t x,
  uint8_t *b,
  uint32_t pos
)
{
  uint32_t bi = (uint32_t)0U;
  uint32_t len = x.len - (uint32_t)0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x1 = FStar_Bytes_get(x.s, (uint32_t)0U + i);
      b[pos - x.len + i] = x1;
      uint32_t i_ = i + (uint32_t)1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  if (FStar_Bytes_get(x.s, (uint32_t)0U) >= (uint8_t)0x80U)
  {
    b[pos - len_of_big_integer_as_octet_string(x)] = (uint8_t)0x00U;
  }
  uint32_t offset_data = len_of_big_integer_as_octet_string(x);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_big_integer_backwards(len_of_big_integer_as_octet_string(x),
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = INTEGER }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag = offset1 + offset2;
  return offset_tag + offset_data;
}

asn1_tag_t
x509_authKeyID_keyIdentifier_tag =
  {
    .tag = CUSTOM_TAG,
    .tag_class = CONTEXT_SPECIFIC,
    .tag_form = PRIMITIVE,
    .tag_value = (uint8_t)0U
  };

static bit_string_t _synth_x509_key_usage_payload_inverse_impl(int32_t ku)
{
  uint8_t b0 = (uint8_t)(ku % (int32_t)0x100);
  uint8_t b1 = (uint8_t)(ku / (int32_t)0x100);
  FStar_Bytes_bytes
  s32 =
    FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b0),
      FStar_Bytes_create((uint32_t)1U, b1));
  return ((bit_string_t){ .bs_len = (uint32_t)3U, .bs_unused_bits = (uint32_t)7U, .bs_s = s32 });
}

static uint32_t
_serialize32_x509_key_usage_payload_backwards(int32_t x, uint8_t *input, uint32_t pos)
{
  return
    serialize32_asn1_bit_string_TLV_backwards(_synth_x509_key_usage_payload_inverse_impl(x),
      input,
      pos);
}

uint32_t
serialize32_x509_key_usage_backwards(K___ASN1_Base_oid_t_int32_t x, uint8_t *b, uint32_t pos)
{
  oid_t x1 = x.fst;
  int32_t x2 = x.snd;
  uint32_t offset_data = _serialize32_x509_key_usage_payload_backwards(x2, b, pos);
  uint32_t
  offset20 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = OCTET_STRING }),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset20 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = OCTET_STRING }));
  uint32_t offset10 = (uint32_t)1U;
  uint32_t offset_tag_len = offset10 + offset20;
  uint32_t offset21 = offset_tag_len + offset_data;
  uint32_t offset11 = serialize32_asn1_oid_TLV_backwards(x1, b, pos - offset21);
  uint32_t offset_data0 = offset11 + offset21;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data0,
      b,
      pos - offset_data0);
  b[pos - offset_data0 - offset2 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag_len0 = offset1 + offset2;
  return offset_tag_len0 + offset_data0;
}

uint32_t serialize32_RDN_COMMON_NAME(x509_rdn_string_t x, uint8_t *b, uint32_t pos)
{
  oid_t x1 = x.fst;
  Prims_dtuple2__uint32_t_FStar_Bytes_bytes x2 = x.snd;
  uint32_t bi = (uint32_t)0U;
  uint32_t len = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2) - (uint32_t)0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x3 = FStar_Bytes_get(dsnd__uint32_t_FStar_Bytes_bytes(x2), (uint32_t)0U + i);
      b[pos - FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2) + i] = x3;
      uint32_t i_ = i + (uint32_t)1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2);
  uint32_t
  offset20 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = IA5_STRING }),
      FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2),
      b,
      pos - offset_data);
  b[pos - offset_data - offset20 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = IA5_STRING }));
  uint32_t offset10 = (uint32_t)1U;
  uint32_t offset_tag = offset10 + offset20;
  uint32_t offset21 = offset_tag + offset_data;
  uint32_t offset11 = serialize32_asn1_oid_TLV_backwards(x1, b, pos - offset21);
  uint32_t offset_data0 = offset11 + offset21;
  uint32_t
  offset22 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data0,
      b,
      pos - offset_data0);
  b[pos - offset_data0 - offset22 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset12 = (uint32_t)1U;
  uint32_t offset_tag_len = offset12 + offset22;
  uint32_t offset_data1 = offset_tag_len + offset_data0;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SET }),
      offset_data1,
      b,
      pos - offset_data1);
  b[pos - offset_data1 - offset2 - (uint32_t)1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SET }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag_len0 = offset1 + offset2;
  return offset_tag_len0 + offset_data1;
}

uint32_t serialize32_RDN_ORGANIZATION(x509_rdn_string_t x, uint8_t *b, uint32_t pos)
{
  oid_t x1 = x.fst;
  Prims_dtuple2__uint32_t_FStar_Bytes_bytes x2 = x.snd;
  uint32_t bi = (uint32_t)0U;
  uint32_t len = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2) - (uint32_t)0U;
  while (true)
  {
    uint32_t i = bi;
    bool ite;
    if (i == len)
    {
      ite = true;
    }
    else
    {
      uint8_t x3 = FStar_Bytes_get(dsnd__uint32_t_FStar_Bytes_bytes(x2), (uint32_t)0U + i);
      b[pos - FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2) + i] = x3;
      uint32_t i_ = i + (uint32_t)1U;
      bi = i_;
      ite = i_ == len;
    }
    if (ite)
    {
      break;
    }
  }
  uint32_t offset_data = FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2);
  uint32_t
  offset20 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = IA5_STRING }),
      FStar_Pervasives_dfst__uint32_t_FStar_Bytes_bytes(x2),
      b,
      pos - offset_data);
  b[pos - offset_data - offset20 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = IA5_STRING }));
  uint32_t offset10 = (uint32_t)1U;
  uint32_t offset_tag = offset10 + offset20;
  uint32_t offset21 = offset_tag + offset_data;
  uint32_t offset11 = serialize32_asn1_oid_TLV_backwards(x1, b, pos - offset21);
  uint32_t offset_data0 = offset11 + offset21;
  uint32_t
  offset22 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data0,
      b,
      pos - offset_data0);
  b[pos - offset_data0 - offset22 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset12 = (uint32_t)1U;
  uint32_t offset_tag_len = offset12 + offset22;
  uint32_t offset_data1 = offset_tag_len + offset_data0;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SET }),
      offset_data1,
      b,
      pos - offset_data1);
  b[pos - offset_data1 - offset2 - (uint32_t)1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SET }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag_len0 = offset1 + offset2;
  return offset_tag_len0 + offset_data1;
}

uint32_t serialize32_RDN_COUNTRY(x509_rdn_string_t x, uint8_t *b, uint32_t pos)
{
  oid_t x1 = x.fst;
  Prims_dtuple2__uint32_t_FStar_Bytes_bytes x2 = x.snd;
  uint32_t
  offset20 = serialize32_asn1_printable_string_TLV_with_character_bound_backwards(x2, b, pos);
  uint32_t offset10 = serialize32_asn1_oid_TLV_backwards(x1, b, pos - offset20);
  uint32_t offset_data = offset10 + offset20;
  uint32_t
  offset21 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset21 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset11 = (uint32_t)1U;
  uint32_t offset_tag_len = offset11 + offset21;
  uint32_t offset_data0 = offset_tag_len + offset_data;
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SET }),
      offset_data0,
      b,
      pos - offset_data0);
  b[pos - offset_data0 - offset2 - (uint32_t)1U] = encode_asn1_tag(((asn1_tag_t){ .tag = SET }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag_len0 = offset1 + offset2;
  return offset_tag_len0 + offset_data0;
}

asn1_tag_t
x509_extensions_outmost_explicit_tag =
  {
    .tag = CUSTOM_TAG,
    .tag_class = CONTEXT_SPECIFIC,
    .tag_form = CONSTRUCTED,
    .tag_value = (uint8_t)3U
  };

uint32_t len_of_x509_extensions(uint32_t len_payload)
{
  return (uint32_t)1U + len_of_asn1_length(len_payload) + len_payload;
}

uint8_t
x509_validity_notBefore_default_buffer[13U] =
  {
    (uint8_t)0x31U, (uint8_t)0x37U, (uint8_t)0x30U, (uint8_t)0x31U, (uint8_t)0x30U, (uint8_t)0x31U,
    (uint8_t)0x30U, (uint8_t)0x30U, (uint8_t)0x30U, (uint8_t)0x30U, (uint8_t)0x30U, (uint8_t)0x30U,
    (uint8_t)0x5AU
  };

uint8_t
x509_validity_notAfter_default_buffer[15U] =
  {
    (uint8_t)0x39U, (uint8_t)0x39U, (uint8_t)0x39U, (uint8_t)0x39U, (uint8_t)0x31U, (uint8_t)0x32U,
    (uint8_t)0x33U, (uint8_t)0x31U, (uint8_t)0x32U, (uint8_t)0x33U, (uint8_t)0x35U, (uint8_t)0x39U,
    (uint8_t)0x35U, (uint8_t)0x39U, (uint8_t)0x5AU
  };

static uint32_t
serialize32_x509_validity_payload_backwards(
  x509_validity_payload_t x,
  uint8_t *input,
  uint32_t pos
)
{
  uint32_t offset2 = serialize32_asn1_generalized_time_TLV_backwards(x.notAfter, input, pos);
  uint32_t offset1 = serialize32_asn1_utc_time_TLV_backwards(x.notBefore, input, pos - offset2);
  return offset1 + offset2;
}

uint32_t
serialize32_x509_validity_backwards(x509_validity_payload_t x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data = serialize32_x509_validity_payload_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag_len = offset1 + offset2;
  return offset_tag_len + offset_data;
}

typedef oid_t algorithmIdentifier_Ed25519_t;

static uint32_t
serialize32_algorithmIdentifier_payload_backwards(oid_t x, uint8_t *input, uint32_t pos)
{
  return serialize32_asn1_oid_TLV_backwards(x, input, pos);
}

uint32_t serialize32_algorithmIdentifier_backwards(oid_t x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data = serialize32_algorithmIdentifier_payload_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag_len = offset1 + offset2;
  return offset_tag_len + offset_data;
}

static uint32_t
serialize32_subjectPublicKeyInfo_payload_backwards(
  subjectPublicKeyInfo_payload_t x,
  uint8_t *input,
  uint32_t pos
)
{
  uint32_t offset2 = serialize32_asn1_bit_string_TLV_backwards(x.subjectPubKey, input, pos);
  uint32_t
  offset1 = serialize32_algorithmIdentifier_backwards(x.subjectPubKey_alg, input, pos - offset2);
  return offset1 + offset2;
}

uint32_t
serialize32_subjectPublicKeyInfo_backwards(
  subjectPublicKeyInfo_payload_t x,
  uint8_t *b,
  uint32_t pos
)
{
  uint32_t offset_data = serialize32_subjectPublicKeyInfo_payload_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag_len = offset1 + offset2;
  return offset_tag_len + offset_data;
}

subjectPublicKeyInfo_payload_t x509_get_subjectPublicKeyInfo(FStar_Bytes_bytes pubkey)
{
  bit_string_t
  pubkey_bs = { .bs_len = (uint32_t)33U, .bs_unused_bits = (uint32_t)0U, .bs_s = pubkey };
  oid_t alg_id = OID_ED25519;
  return
    ((subjectPublicKeyInfo_payload_t){ .subjectPubKey_alg = alg_id, .subjectPubKey = pubkey_bs });
}

uint32_t len_of_x509_serialNumber(octet_string_t x)
{
  return len_of_big_integer_as_octet_string_TLV(x);
}

uint32_t
serialize32_x509_serialNumber_backwards(octet_string_t x, uint8_t *input, uint32_t pos)
{
  return serialize32_big_integer_as_octet_string_TLV_backwards(x, input, pos);
}

static uint32_t
serialize32_x509_version_payload_backwards(int32_t x, uint8_t *input, uint32_t pos)
{
  return serialize32_asn1_integer_TLV_backwards(x, input, pos);
}

uint32_t serialize32_x509_version_backwards(int32_t x, uint8_t *b, uint32_t pos)
{
  uint32_t offset_data = serialize32_x509_version_payload_backwards(x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards((
        (asn1_tag_t){
          .tag = CUSTOM_TAG,
          .tag_class = CONTEXT_SPECIFIC,
          .tag_form = CONSTRUCTED,
          .tag_value = (uint8_t)0U
        }
      ),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] =
    encode_asn1_tag((
        (asn1_tag_t){
          .tag = CUSTOM_TAG,
          .tag_class = CONTEXT_SPECIFIC,
          .tag_form = CONSTRUCTED,
          .tag_value = (uint8_t)0U
        }
      ));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag_len = offset1 + offset2;
  return offset_tag_len + offset_data;
}

