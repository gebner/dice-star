/* Automatically generated by the Kremlin tool */



#include "DICE_Engine_Core.h"

#include "internal/Hacl_Lib.h"

bool authenticate_l0_image(HWState_l0_image_t img)
{
  bool
  valid_header_sig =
    Hacl_Ed25519_verify(img.l0_image_auth_pubkey,
      img.l0_image_header_size,
      img.l0_image_header,
      img.l0_image_header_sig);
  if (valid_header_sig)
  {
    uint8_t hash_buf[32U];
    memset(hash_buf, 0U, 32U * sizeof (uint8_t));
    Hacl_Streaming_SHA2_hash_256(hash_buf, img.l0_binary, img.l0_binary_size);
    uint8_t res = 255U;
    for (uint32_t i = 0U; i < 32U; i++)
    {
      uint8_t uu____0 = FStar_UInt8_eq_mask(img.l0_binary_hash[i], hash_buf[i]);
      res = (uint32_t)uu____0 & (uint32_t)res;
    }
    uint8_t z = res;
    bool b = z == 255U;
    return b;
  }
  return false;
}

bool uu___is_DICE_SUCCESS(dice_return_code projectee)
{
  switch (projectee)
  {
    case DICE_SUCCESS:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool uu___is_DICE_ERROR(dice_return_code projectee)
{
  switch (projectee)
  {
    case DICE_ERROR:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

dice_return_code dice_main(void)
{
  HWState_state s = st();
  bool b = authenticate_l0_image(s.l0);
  dice_return_code r;
  if (b)
  {
    KRML_CHECK_SIZE(sizeof (uint8_t), uds_len);
    uint8_t uds[uds_len];
    memset(uds, 0U, uds_len * sizeof (uint8_t));
    read_uds(uds);
    uint8_t uds_digest[32U];
    memset(uds_digest, 0U, 32U * sizeof (uint8_t));
    uint8_t l0_digest[32U];
    memset(l0_digest, 0U, 32U * sizeof (uint8_t));
    Hacl_Streaming_SHA2_hash_256(uds_digest, uds, uds_len);
    Hacl_Streaming_SHA2_hash_256(l0_digest, s.l0.l0_binary, s.l0.l0_binary_size);
    Hacl_HMAC_compute_sha2_256(s.cdi, uds_digest, 32U, l0_digest, 32U);
    zeroize(uds_len, uds);
    r = DICE_SUCCESS;
  }
  else
  {
    r = DICE_ERROR;
  }
  disable_uds();
  platform_zeroize_stack();
  return r;
}

