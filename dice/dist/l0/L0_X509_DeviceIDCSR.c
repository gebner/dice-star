/* Automatically generated by the Kremlin tool */



#include "L0_X509_DeviceIDCSR.h"

uint32_t len_of_deviceIDCSR_payload(uint32_t cri_len)
{
  return cri_len + (uint32_t)74U;
}

uint32_t len_of_deviceIDCSR(uint32_t cri_len)
{
  return
    (uint32_t)1U
    + len_of_asn1_length(len_of_deviceIDCSR_payload(cri_len))
    + len_of_deviceIDCSR_payload(cri_len);
}

uint32_t
serialize32_deviceIDCSR_payload_backwards(
  uint32_t cri_len,
  deviceIDCSR_payload_t x,
  uint8_t *input,
  uint32_t pos
)
{
  uint32_t offset2 = serialize32_asn1_bit_string_TLV_backwards(x.deviceIDCSR_sig, input, pos);
  uint32_t
  offset21 =
    serialize32_algorithmIdentifier_backwards(x.deviceIDCSR_sig_alg,
      input,
      pos - offset2);
  uint32_t
  offset1 =
    serialize32_flbytes32_backwards(cri_len,
      x.deviceIDCSR_cri,
      input,
      pos - offset2 - offset21);
  uint32_t offset10 = offset1 + offset21;
  return offset10 + offset2;
}

uint32_t
serialize32_deviceIDCSR_backwards(
  uint32_t cri_len,
  deviceIDCSR_payload_t x,
  uint8_t *b,
  uint32_t pos
)
{
  uint32_t offset_data = serialize32_deviceIDCSR_payload_backwards(cri_len, x, b, pos);
  uint32_t
  offset2 =
    serialize32_asn1_length_of_type_backwards(((asn1_tag_t){ .tag = SEQUENCE }),
      offset_data,
      b,
      pos - offset_data);
  b[pos - offset_data - offset2 - (uint32_t)1U] =
    encode_asn1_tag(((asn1_tag_t){ .tag = SEQUENCE }));
  uint32_t offset1 = (uint32_t)1U;
  uint32_t offset_tag_len = offset1 + offset2;
  return offset_tag_len + offset_data;
}

deviceIDCSR_payload_t
x509_get_deviceIDCSR(
  uint32_t cri_len,
  FStar_Bytes_bytes deviceIDCSR_cri,
  FStar_Bytes_bytes signature32
)
{
  oid_t deviceIDCSR_sig_alg = OID_ED25519;
  bit_string_t
  deviceIDCSR_sig =
    { .bs_len = (uint32_t)65U, .bs_unused_bits = (uint32_t)0U, .bs_s = signature32 };
  return
    (
      (deviceIDCSR_payload_t){
        .deviceIDCSR_cri = deviceIDCSR_cri,
        .deviceIDCSR_sig_alg = deviceIDCSR_sig_alg,
        .deviceIDCSR_sig = deviceIDCSR_sig
      }
    );
}

