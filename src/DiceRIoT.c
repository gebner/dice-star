/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -no-prefix DiceRIoT DiceRIoT.fst -skip-compilation -drop WasmSupport -tmpdir out
  F* version: <unknown>
  KreMLin version: 2f843633
 */

#include "DiceRIoT.h"

uint32_t _DICE_DIGEST_LENGTH = (uint32_t)0x20U;

uint32_t _DICE_UDS_LENGTH = (uint32_t)0x20U;

uint32_t _DER_MAX_PEM = (uint32_t)0x400U;

uint32_t _SHA256_DIGEST_LENGTH = (uint32_t)0x20U;

Prims_list__uint8_t *udslist;

#define UDS 0

typedef uint8_t uds_t_tags;

bool uu___is_UDS(uint32_t len, uint8_t *projectee)
{
  return true;
}

uint8_t *__proj__UDS__item__data(uint32_t len, uint8_t *projectee)
{
  return projectee;
}

#define CDI 0

typedef uint8_t cdi_t_tags;

bool uu___is_CDI(uint32_t len, uint8_t *projectee)
{
  return true;
}

uint8_t *__proj__CDI__item__data(uint32_t len, uint8_t *projectee)
{
  return projectee;
}

#define CERT 0

typedef uint8_t cert_t_tags;

bool uu___is_CERT(uint32_t len, uint8_t *projectee)
{
  return true;
}

uint8_t *__proj__CERT__item__data(uint32_t len, uint8_t *projectee)
{
  return projectee;
}

uint32_t _BIGLEN = (uint32_t)0x09U;

uint32_t *__proj__Mkbigval_t__item__data(uint32_t *projectee)
{
  return projectee;
}

uint32_t *__proj__Mkaffine_point_t__item__x(affine_point_t projectee)
{
  return projectee.x;
}

uint32_t *__proj__Mkaffine_point_t__item__y(affine_point_t projectee)
{
  return projectee.y;
}

uint32_t *__proj__Mkaffine_point_t__item__infinity(affine_point_t projectee)
{
  return projectee.infinity;
}

uint32_t *__proj__Mkecdsa_sig_t__item__r(ecdsa_sig_t projectee)
{
  return projectee.r;
}

uint32_t *__proj__Mkecdsa_sig_t__item__s(ecdsa_sig_t projectee)
{
  return projectee.s;
}

#define RIoT_ECC_PublicKey 0

typedef uint8_t riot_ecc_publickey_tags;

bool uu___is_RIoT_ECC_PublicKey(affine_point_t projectee)
{
  return true;
}

affine_point_t __proj__RIoT_ECC_PublicKey__item___0(affine_point_t projectee)
{
  return projectee;
}

#define RIoT_ECC_PrivateKey 0

typedef uint8_t riot_ecc_privatekey_tags;

bool uu___is_RIoT_ECC_PrivateKey(ecdsa_sig_t projectee)
{
  return true;
}

ecdsa_sig_t __proj__RIoT_ECC_PrivateKey__item___0(ecdsa_sig_t projectee)
{
  return projectee;
}

#define Digest 0

typedef uint8_t digest_t_tags;

bool uu___is_Digest(uint32_t len, uint8_t *projectee)
{
  return true;
}

uint8_t *__proj__Digest__item___0(uint32_t len, uint8_t *projectee)
{
  return projectee;
}

uint8_t *__proj__Mkriot_x509_tbs_data__item__serialNum(riot_x509_tbs_data projectee)
{
  return projectee.serialNum;
}

uint8_t *__proj__Mkriot_x509_tbs_data__item__issuerCommon(riot_x509_tbs_data projectee)
{
  return projectee.issuerCommon;
}

uint8_t *__proj__Mkriot_x509_tbs_data__item__issuerOrg(riot_x509_tbs_data projectee)
{
  return projectee.issuerOrg;
}

uint8_t *__proj__Mkriot_x509_tbs_data__item__issuerCountry(riot_x509_tbs_data projectee)
{
  return projectee.issuerCountry;
}

uint8_t *__proj__Mkriot_x509_tbs_data__item__validForm(riot_x509_tbs_data projectee)
{
  return projectee.validForm;
}

uint8_t *__proj__Mkriot_x509_tbs_data__item__validTo(riot_x509_tbs_data projectee)
{
  return projectee.validTo;
}

uint8_t *__proj__Mkriot_x509_tbs_data__item__subjectCommon(riot_x509_tbs_data projectee)
{
  return projectee.subjectCommon;
}

uint8_t *__proj__Mkriot_x509_tbs_data__item__subjectOrg(riot_x509_tbs_data projectee)
{
  return projectee.subjectOrg;
}

uint8_t *__proj__Mkriot_x509_tbs_data__item__subjectCountry(riot_x509_tbs_data projectee)
{
  return projectee.subjectCountry;
}

void riotCrypto_Hash(uint32_t digestLen, uint8_t *cDigest, uint32_t cdiLen, uint8_t *cdi)
{
  
}

void
riotCrypto_DeriveEccKey(
  affine_point_t deviceIDPub,
  ecdsa_sig_t deviceIDPriv,
  uint32_t digestLen,
  uint8_t *cDigest
)
{
  
}

void riotStart(uint32_t cdiLen, uint8_t *cdi)
{
  KRML_CHECK_SIZE(sizeof (uint32_t), _BIGLEN);
  uint32_t buf0[_BIGLEN];
  memset(buf0, 0U, _BIGLEN * sizeof buf0[0U]);
  KRML_CHECK_SIZE(sizeof (uint32_t), _BIGLEN);
  uint32_t buf1[_BIGLEN];
  memset(buf1, 0U, _BIGLEN * sizeof buf1[0U]);
  uint32_t buf2 = (uint32_t)0U;
  affine_point_t deviceIDPub = { .x = buf0, .y = buf1, .infinity = &buf2 };
  KRML_CHECK_SIZE(sizeof (uint32_t), _BIGLEN);
  uint32_t buf3[_BIGLEN];
  memset(buf3, 0U, _BIGLEN * sizeof buf3[0U]);
  KRML_CHECK_SIZE(sizeof (uint32_t), _BIGLEN);
  uint32_t buf4[_BIGLEN];
  memset(buf4, 0U, _BIGLEN * sizeof buf4[0U]);
  uint32_t buf5 = (uint32_t)0U;
  affine_point_t aliasKeyPub = { .x = buf3, .y = buf4, .infinity = &buf5 };
  KRML_CHECK_SIZE(sizeof (uint32_t), _BIGLEN);
  uint32_t buf6[_BIGLEN];
  memset(buf6, 0U, _BIGLEN * sizeof buf6[0U]);
  KRML_CHECK_SIZE(sizeof (uint32_t), _BIGLEN);
  uint32_t buf7[_BIGLEN];
  memset(buf7, 0U, _BIGLEN * sizeof buf7[0U]);
  ecdsa_sig_t aliasKeyPriv = { .r = buf6, .s = buf7 };
  KRML_CHECK_SIZE(sizeof (uint8_t), _DER_MAX_PEM);
  uint8_t aliasCert[_DER_MAX_PEM];
  memset(aliasCert, 0U, _DER_MAX_PEM * sizeof aliasCert[0U]);
  KRML_CHECK_SIZE(sizeof (uint8_t), _DER_MAX_PEM);
  uint8_t deviceCert[_DER_MAX_PEM];
  memset(deviceCert, 0U, _DER_MAX_PEM * sizeof deviceCert[0U]);
  KRML_CHECK_SIZE(sizeof (uint8_t), _DER_MAX_PEM);
  uint8_t r00tCert[_DER_MAX_PEM];
  memset(r00tCert, 0U, _DER_MAX_PEM * sizeof r00tCert[0U]);
  KRML_CHECK_SIZE(sizeof (uint8_t), _DICE_DIGEST_LENGTH);
  uint8_t cDigest[_DICE_DIGEST_LENGTH];
  memset(cDigest, 0U, _DICE_DIGEST_LENGTH * sizeof cDigest[0U]);
  KRML_CHECK_SIZE(sizeof (uint32_t), _BIGLEN);
  uint32_t buf8[_BIGLEN];
  memset(buf8, 0U, _BIGLEN * sizeof buf8[0U]);
  KRML_CHECK_SIZE(sizeof (uint32_t), _BIGLEN);
  uint32_t buf[_BIGLEN];
  memset(buf, 0U, _BIGLEN * sizeof buf[0U]);
  ecdsa_sig_t deviceIDPriv = { .r = buf8, .s = buf };
  riotCrypto_Hash(_DICE_DIGEST_LENGTH, cDigest, cdiLen, cdi);
  riotCrypto_DeriveEccKey(deviceIDPub, deviceIDPriv, _DICE_DIGEST_LENGTH, cDigest);
}

exit_code main()
{
  kremlinit_globals();
  uint8_t
  uds[32U] =
    {
      (uint8_t)0xb5U, (uint8_t)0x85U, (uint8_t)0x94U, (uint8_t)0x93U, (uint8_t)0x66U, (uint8_t)0x1eU,
      (uint8_t)0x2eU, (uint8_t)0xaeU, (uint8_t)0x96U, (uint8_t)0x77U, (uint8_t)0xc5U, (uint8_t)0x5dU,
      (uint8_t)0x59U, (uint8_t)0x0bU, (uint8_t)0x92U, (uint8_t)0x94U, (uint8_t)0xe0U, (uint8_t)0x94U,
      (uint8_t)0xabU, (uint8_t)0xafU, (uint8_t)0xd7U, (uint8_t)0x40U, (uint8_t)0x78U, (uint8_t)0x7eU,
      (uint8_t)0x05U, (uint8_t)0x0dU, (uint8_t)0xfeU, (uint8_t)0x6dU, (uint8_t)0x85U, (uint8_t)0x90U,
      (uint8_t)0x53U, (uint8_t)0xa0U
    };
  KRML_CHECK_SIZE(sizeof (uint8_t), _DICE_DIGEST_LENGTH);
  uint8_t cdi[_DICE_DIGEST_LENGTH];
  memset(cdi, 0U, _DICE_DIGEST_LENGTH * sizeof cdi[0U]);
  KRML_CHECK_SIZE(sizeof (uint8_t), _DICE_DIGEST_LENGTH);
  uint8_t uDigest[_DICE_DIGEST_LENGTH];
  memset(uDigest, 0U, _DICE_DIGEST_LENGTH * sizeof uDigest[0U]);
  KRML_CHECK_SIZE(sizeof (uint8_t), _DICE_DIGEST_LENGTH);
  uint8_t rDigest[_DICE_DIGEST_LENGTH];
  memset(rDigest, 0U, _DICE_DIGEST_LENGTH * sizeof rDigest[0U]);
  KRML_CHECK_SIZE(sizeof (uint8_t), _DICE_DIGEST_LENGTH);
  uint8_t uDigest1[_DICE_DIGEST_LENGTH];
  memset(uDigest1, 0U, _DICE_DIGEST_LENGTH * sizeof uDigest1[0U]);
  KRML_CHECK_SIZE(sizeof (uint8_t), _DICE_DIGEST_LENGTH);
  uint8_t rDigest1[_DICE_DIGEST_LENGTH];
  memset(rDigest1, 0U, _DICE_DIGEST_LENGTH * sizeof rDigest1[0U]);
  riotStart(_DICE_DIGEST_LENGTH, cdi);
  return EXIT_SUCCESS;
}

