/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -no-prefix DiceRIoT DiceRIoT.fst -skip-compilation -drop WasmSupport -tmpdir out
  F* version: <unknown>
  KreMLin version: 2f843633
 */

#include "kremlib.h"
#ifndef __DiceRIoT_H
#define __DiceRIoT_H

#include "kremlinit.h"
#include "C.h"


extern uint32_t _DICE_DIGEST_LENGTH;

extern uint32_t _DICE_UDS_LENGTH;

extern uint32_t _DER_MAX_PEM;

extern uint32_t _SHA256_DIGEST_LENGTH;

typedef struct Prims_list__uint8_t_s Prims_list__uint8_t;

#define Prims_Nil 0
#define Prims_Cons 1

typedef uint8_t Prims_list__uint8_t_tags;

typedef struct Prims_list__uint8_t_s
{
  Prims_list__uint8_t_tags tag;
  uint8_t hd;
  Prims_list__uint8_t *tl;
}
Prims_list__uint8_t;

extern Prims_list__uint8_t *udslist;

typedef uint8_t *uds_t;

bool uu___is_UDS(uint32_t len, uint8_t *projectee);

uint8_t *__proj__UDS__item__data(uint32_t len, uint8_t *projectee);

typedef uint8_t *cdi_t;

bool uu___is_CDI(uint32_t len, uint8_t *projectee);

uint8_t *__proj__CDI__item__data(uint32_t len, uint8_t *projectee);

typedef uint8_t *cert_t;

bool uu___is_CERT(uint32_t len, uint8_t *projectee);

uint8_t *__proj__CERT__item__data(uint32_t len, uint8_t *projectee);

extern uint32_t _BIGLEN;

typedef uint32_t *bigval_t;

uint32_t *__proj__Mkbigval_t__item__data(uint32_t *projectee);

typedef struct affine_point_t_s
{
  uint32_t *x;
  uint32_t *y;
  uint32_t *infinity;
}
affine_point_t;

uint32_t *__proj__Mkaffine_point_t__item__x(affine_point_t projectee);

uint32_t *__proj__Mkaffine_point_t__item__y(affine_point_t projectee);

uint32_t *__proj__Mkaffine_point_t__item__infinity(affine_point_t projectee);

typedef struct ecdsa_sig_t_s
{
  uint32_t *r;
  uint32_t *s;
}
ecdsa_sig_t;

uint32_t *__proj__Mkecdsa_sig_t__item__r(ecdsa_sig_t projectee);

uint32_t *__proj__Mkecdsa_sig_t__item__s(ecdsa_sig_t projectee);

typedef affine_point_t riot_ecc_publickey;

bool uu___is_RIoT_ECC_PublicKey(affine_point_t projectee);

affine_point_t __proj__RIoT_ECC_PublicKey__item___0(affine_point_t projectee);

typedef ecdsa_sig_t riot_ecc_privatekey;

bool uu___is_RIoT_ECC_PrivateKey(ecdsa_sig_t projectee);

ecdsa_sig_t __proj__RIoT_ECC_PrivateKey__item___0(ecdsa_sig_t projectee);

typedef uint8_t *digest_t;

bool uu___is_Digest(uint32_t len, uint8_t *projectee);

uint8_t *__proj__Digest__item___0(uint32_t len, uint8_t *projectee);

typedef struct riot_x509_tbs_data_s
{
  uint8_t *serialNum;
  uint8_t *issuerCommon;
  uint8_t *issuerOrg;
  uint8_t *issuerCountry;
  uint8_t *validForm;
  uint8_t *validTo;
  uint8_t *subjectCommon;
  uint8_t *subjectOrg;
  uint8_t *subjectCountry;
}
riot_x509_tbs_data;

uint8_t *__proj__Mkriot_x509_tbs_data__item__serialNum(riot_x509_tbs_data projectee);

uint8_t *__proj__Mkriot_x509_tbs_data__item__issuerCommon(riot_x509_tbs_data projectee);

uint8_t *__proj__Mkriot_x509_tbs_data__item__issuerOrg(riot_x509_tbs_data projectee);

uint8_t *__proj__Mkriot_x509_tbs_data__item__issuerCountry(riot_x509_tbs_data projectee);

uint8_t *__proj__Mkriot_x509_tbs_data__item__validForm(riot_x509_tbs_data projectee);

uint8_t *__proj__Mkriot_x509_tbs_data__item__validTo(riot_x509_tbs_data projectee);

uint8_t *__proj__Mkriot_x509_tbs_data__item__subjectCommon(riot_x509_tbs_data projectee);

uint8_t *__proj__Mkriot_x509_tbs_data__item__subjectOrg(riot_x509_tbs_data projectee);

uint8_t *__proj__Mkriot_x509_tbs_data__item__subjectCountry(riot_x509_tbs_data projectee);

void riotCrypto_Hash(uint32_t digestLen, uint8_t *cDigest, uint32_t cdiLen, uint8_t *cdi);

void
riotCrypto_DeriveEccKey(
  affine_point_t deviceIDPub,
  ecdsa_sig_t deviceIDPriv,
  uint32_t digestLen,
  uint8_t *cDigest
);

void riotStart(uint32_t cdiLen, uint8_t *cdi);

exit_code main();

#define __DiceRIoT_H_DEFINED
#endif
