module RIoT.Base

open LowStar.Comment

module Fail = LowStar.Failure
module B = LowStar.Buffer
module HS  = FStar.HyperStack
module HST = FStar.HyperStack.ST

module SHA2 = Hacl.Hash.SHA2
module HMAC = Hacl.HMAC
module HKDF = Hacl.HKDF
module ECDSA = Hacl.Impl.ECDSA
module P256 = Hacl.Impl.P256
module Ed25519 = Hacl.Ed25519
module Curve25519 = Hacl.Curve25519_51

// module HW = HWAbstraction
open RIoT.Declassify
open Lib.IntTypes
open Spec.Hash.Definitions
open Hacl.Hash.Definitions
(*
 * Some common definitions used in the RIoT code
 *)

#set-options "--__temp_no_proj RIoT.Definitions"

(* ZT: restrict it to `SHA2_256` for convenience,
       because `Hacl.Curve25519` only support it *)
type riot_hash_alg = a:hash_alg{a == SHA2_256}

inline_for_extraction
let alg : riot_hash_alg = SHA2_256

inline_for_extraction noextract
let riot_hash (alg:riot_hash_alg) : hash_st alg =
  match alg with
  | SHA2_256 -> Hacl.Hash.SHA2.hash_256
  | SHA2_384 -> Hacl.Hash.SHA2.hash_384
  | SHA2_512 -> Hacl.Hash.SHA2.hash_512
  | SHA1     -> Hacl.Hash.SHA1.legacy_hash

inline_for_extraction noextract
let riot_hmac (alg:riot_hash_alg) : Hacl.HMAC.compute_st alg =
  match alg with
  | SHA2_256 -> Hacl.HMAC.compute_sha2_256
  | SHA2_384 -> Hacl.HMAC.compute_sha2_384
  | SHA2_512 -> Hacl.HMAC.compute_sha2_512
  | SHA1     -> Hacl.HMAC.legacy_compute_sha1

unfold let digest_len = hash_len alg

unfold type digest_t = hash_t alg

unfold type hashable_len = i:size_t{0 < v i /\ v i <= max_input_length alg}

unfold let cdi_len = digest_len


/// Some types used in the public key verification of the RIoT header

unfold type signature_t = B.lbuffer uint8 64
unfold type key_t = B.lbuffer uint8 32

(*                           RFC 5869: HKDF
  =======================================================================
2.2.  Step 1: Extract

   HKDF-Extract(salt, IKM) -> PRK

   Options:
      Hash     a hash function; HashLen denotes the length of the
               hash function output in octets

   Inputs:
      salt     optional salt value (a non-secret random value);
               if not provided, it is set to a string of HashLen zeros.
      IKM      input keying material

   Output:
      PRK      a pseudorandom key (of HashLen octets)

   The output PRK is calculated as follows:

   PRK = HMAC-Hash(salt, IKM)

2.3.  Step 2: Expand

   HKDF-Expand(PRK, info, L) -> OKM

   Options:
      Hash     a hash function; HashLen denotes the length of the
               hash function output in octets

   Inputs:
      PRK      a pseudorandom key of at least HashLen octets
               (usually, the output from the extract step)
      info     optional context and application specific information
               (can be a zero-length string)
      L        length of output keying material in octets
               (<= 255*HashLen)

   Output:
      OKM      output keying material (of L octets)
*)

(*                  RFC 8032 EdDSA: Ed25519 and Ed448
  =======================================================================
5.1.5.  Key Generation

   The private key is 32 octets (256 bits, corresponding to b) of
   cryptographically secure random data.  See [RFC4086] for a discussion
   about randomness.

   The 32-byte public key is generated by the following steps.

   1.  Hash the 32-byte private key using SHA-512, storing the digest in
       a 64-octet large buffer, denoted h.  Only the lower 32 bytes are
       used for generating the public key.

   2.  Prune the buffer: The lowest three bits of the first octet are
       cleared, the highest bit of the last octet is cleared, and the
       second highest bit of the last octet is set.

   3.  Interpret the buffer as the little-endian integer, forming a
       secret scalar s.  Perform a fixed-base scalar multiplication
       [s]B.

   4.  The public key A is the encoding of the point [s]B.  First,
       encode the y-coordinate (in the range 0 <= y < p) as a little-
       endian string of 32 octets.  The most significant bit of the
       final octet is always zero.  To form the encoding of the point
       [s]B, copy the least significant bit of the x coordinate to the
       most significant bit of the final octet.  The result is the
       public key.
*)

let riot_derive_key_pair_spec
  (ikm_len: size_t { (* for Hacl.HKDF.extract_st *)
                     v ikm_len + block_length alg < pow2 32 /\
                     (* for Spec.Agile.HKDF.extract *)
                     v ikm_len + block_length alg <= max_input_length alg })
  (ikm: Seq.lseq uint8 (v ikm_len))
  (lbl_len: size_t { (* for Hacl.HKDF.expand_st *)
                     hash_length alg + v lbl_len + 1 + block_length alg < pow2 32 /\
                     (* for Spec.Aigle.HKDF.expand *)
                     hash_length alg + v lbl_len + 1 + block_length alg < max_input_length alg })
  (lbl: Seq.lseq uint8 (v lbl_len))
: GTot (Seq.lseq pub_uint8 32 & Seq.lseq uint8 32)
= let alg = SHA2_256 in
  (* Derive private key from `ikm` and `lbl` using HKDF *)
  (* Step 1. extract a `prk` (Pseudo Random Key) from an empty `salt` of `hashLen` and `ikm` *)
  let salt = Seq.create (v (hash_len alg)) (u8 0x00) in
  let prk  = Spec.Agile.HKDF.extract
               (* alg *) alg
               (* salt*) salt
               (* ikm *) ikm in
  (* Step 2. expand `prk` and `lbl` to a `okm` (Output Keying Material) *)
  let private_key = Spec.Agile.HKDF.expand
                       (* alg *) alg
                       (* prk *) prk
                       (* info*) lbl
                       (* len *) (hash_length alg) in

  (* Derive public key from private key using Ed25519 (FIXME: Or Curve25519?) *)
  let public_key = declassify_secret_bytes 32 (Spec.Ed25519.secret_to_public private_key) in

(* return *) (public_key, private_key)

#push-options "--z3rlimit 32"
let riot_derive_key_pair
  (public_key : B.lbuffer pub_uint8 32)                 // Out
  (private_key: B.lbuffer uint8 32)                     // Out
                    (* NOTE Not using lbuffer here because lbuffer doesn't accept null *)
  (ikm_len: size_t) (ikm: B.buffer uint8 {B.length ikm == v ikm_len})  // In: Initial Data for derivation
  (lbl_len: size_t) (lbl: B.buffer uint8 {B.length lbl == v lbl_len})  // In: Label for derivation
: HST.Stack unit
  (requires fun h -> let alg = SHA2_256 in
    (* Separation Logic Properties *)
    B.live h ikm /\ B.live h lbl /\ B.live h public_key /\ B.live h private_key /\
    B.all_disjoint [B.loc_buffer ikm;
                    B.loc_buffer lbl;
                    B.loc_buffer public_key;
                    B.loc_buffer private_key] /\

    (* for Hacl.HKDF.extract_st *)
    v ikm_len + block_length alg < pow2 32 /\
    (* for Spec.Agile.HKDF.extract *)
    v ikm_len + block_length alg <= max_input_length alg /\
    (* for Hacl.HKDF.expand_st *)
    hash_length alg + v lbl_len + 1 + block_length alg < pow2 32 /\
    (* for Spec.Aigle.HKDF.expand *)
    hash_length alg + v lbl_len + 1 + block_length alg < max_input_length alg)
  (ensures  fun h0 _ h1 -> let alg = SHA2_256 in
    B.(modifies ((loc_buffer public_key) `loc_union` (loc_buffer private_key)) h0 h1) /\
   (let pub_seq, priv_seq = riot_derive_key_pair_spec ikm_len (B.as_seq h0 ikm) lbl_len (B.as_seq h0 lbl) in
    B.as_seq h1 public_key == pub_seq /\ B.as_seq h1 private_key == priv_seq ))
= HST.push_frame ();

  (* NOTE:  Using SHA2_256 because Curve25519/Ed25519 requires a 32-bit private key *)
  let alg = SHA2_256 in

  (* Using an empty (0x00) buffer of hashLen as salt. *)
  let salt: b:B.lbuffer uint8 32 {Spec.Agile.HMAC.keysized alg (B.length b)} = B.alloca (u8 0x00) (hash_len alg) in

  (* Derive private key from `ikm` and `lbl` using HKDF *)
  (* Step 1. extract a `prk` (Pseudo Random Key) from an empty `salt` of `hashLen` and `ikm` *)
  let prk : b:B.lbuffer uint8 32 {B.length b == hash_length alg} = B.alloca (u8 0x00) (hash_len alg) in
  HKDF.extract_sha2_256
    prk                 // out: Pseudo Random Key
    salt (hash_len alg) // in : (optional) Salt
    ikm  ikm_len;       // in : Input Keying Material

  (* Step 2. expand `prk` and `lbl` to a `okm` (Output Keying Material) *)
  (**)assert_norm (Spec.Agile.HMAC.keysized alg (hash_length alg));
  HKDF.expand_sha2_256
    private_key        // out: Output Keying Material
    prk (hash_len alg) // in : Pseudo Random Key
    lbl lbl_len        // in : (optional) Info
    (hash_len alg);    // in : okm len

  (* Derive public key from private key using Ed25519 (FIXME: Or Curve25519?) *)
  let secret_public_key: B.lbuffer uint8 32 = B.alloca (u8 0) 32ul in
  Ed25519.secret_to_public
    secret_public_key   // out: public
    private_key; // in : secret

  declassify_secret_buffer
    (* len *) 32ul
    (* src *) secret_public_key
    (* dst *) public_key;

  HST.pop_frame ()
#pop-options
