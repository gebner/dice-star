module RIoT.Base

open LowStar.Comment

module Fail = LowStar.Failure
module B = LowStar.Buffer
module HS  = FStar.HyperStack
module HST = FStar.HyperStack.ST

module SHA2 = Hacl.Hash.SHA2
module HMAC = Hacl.HMAC
module HKDF = Hacl.HKDF
module ECDSA = Hacl.Impl.ECDSA
// module P256 = Hacl.Impl.P256
module Ed25519 = Hacl.Ed25519
module Curve25519 = Hacl.Curve25519_51

// module HW = HWAbstraction
open RIoT.Declassify
open Lib.IntTypes
open Spec.Hash.Definitions
open Hacl.Hash.Definitions
(*
 * Some common definitions used in the RIoT code
 *)

#set-options "--__temp_no_proj RIoT.Definitions"

(* ZT: restrict it to `SHA2_256` for convenience,
       because `Hacl.Curve25519` only support it *)
type riot_hash_alg = a:hash_alg{a == SHA2_256}

inline_for_extraction
let alg : riot_hash_alg = SHA2_256

inline_for_extraction noextract
let riot_hash (alg:riot_hash_alg) : hash_st alg =
  match alg with
  | SHA2_256 -> Hacl.Hash.SHA2.hash_256
  | SHA2_384 -> Hacl.Hash.SHA2.hash_384
  | SHA2_512 -> Hacl.Hash.SHA2.hash_512
  | SHA1     -> Hacl.Hash.SHA1.legacy_hash

inline_for_extraction noextract
let riot_hmac (alg:riot_hash_alg) : Hacl.HMAC.compute_st alg =
  match alg with
  | SHA2_256 -> Hacl.HMAC.compute_sha2_256
  | SHA2_384 -> Hacl.HMAC.compute_sha2_384
  | SHA2_512 -> Hacl.HMAC.compute_sha2_512
  | SHA1     -> Hacl.HMAC.legacy_compute_sha1

unfold let digest_len = hash_len alg

unfold type digest_t = hash_t alg

unfold type hashable_len = i:size_t{0 < v i /\ v i <= max_input_length alg}

unfold let cdi_len = digest_len


/// Some types used in the public key verification of the RIoT header

unfold type signature_t = B.lbuffer uint8 64
unfold type key_t = B.lbuffer uint8 32

unfold let byte_sec = uint8
unfold let byte_pub = pub_uint8

unfold let bytes_pub  = Seq.seq byte_pub
unfold let lbytes_pub = Seq.lseq byte_pub
unfold let bytes_sec  = Seq.seq byte_sec
unfold let lbytes_sec = Seq.lseq byte_sec

// unfold let bytesBuffer_pub  = Seq.seq pub_uint8
// unfold let lbyteBuffer_pub = Seq.lseq pub_uint8
// unfold let byteBuffer_sec  = Seq.seq uint8
// unfold let lbyteBuffer_sec = Seq.lseq uint8

unfold
let valid_hkdf_ikm_len
  (len: size_t)
= (* for Hacl.HKDF.extract_st *)
  v len + block_length alg < pow2 32 /\
  (* for Spec.Agile.HKDF.extract *)
  v len + block_length alg <= max_input_length alg

unfold
let valid_hkdf_lbl_len
  (len: size_t)
= (* for Hacl.HKDF.expand_st *)
  hash_length alg + v len + 1 + block_length alg < pow2 32 /\
  (* for Spec.Aigle.HKDF.expand *)
  hash_length alg + v len + 1 + block_length alg < max_input_length alg

(*                           RFC 5869: HKDF
  =======================================================================
2.2.  Step 1: Extract

   HKDF-Extract(salt, IKM) -> PRK

   Options:
      Hash     a hash function; HashLen denotes the length of the
               hash function output in octets

   Inputs:
      salt     optional salt value (a non-secret random value);
               if not provided, it is set to a string of HashLen zeros.
      IKM      input keying material

   Output:
      PRK      a pseudorandom key (of HashLen octets)

   The output PRK is calculated as follows:

   PRK = HMAC-Hash(salt, IKM)

2.3.  Step 2: Expand

   HKDF-Expand(PRK, info, L) -> OKM

   Options:
      Hash     a hash function; HashLen denotes the length of the
               hash function output in octets

   Inputs:
      PRK      a pseudorandom key of at least HashLen octets
               (usually, the output from the extract step)
      info     optional context and application specific information
               (can be a zero-length string)
      L        length of output keying material in octets
               (<= 255*HashLen)

   Output:
      OKM      output keying material (of L octets)
*)

(*                  RFC 8032 EdDSA: Ed25519 and Ed448
  =======================================================================
5.1.5.  Key Generation

   The private key is 32 octets (256 bits, corresponding to b) of
   cryptographically secure random data.  See [RFC4086] for a discussion
   about randomness.

   The 32-byte public key is generated by the following steps.

   1.  Hash the 32-byte private key using SHA-512, storing the digest in
       a 64-octet large buffer, denoted h.  Only the lower 32 bytes are
       used for generating the public key.

   2.  Prune the buffer: The lowest three bits of the first octet are
       cleared, the highest bit of the last octet is cleared, and the
       second highest bit of the last octet is set.

   3.  Interpret the buffer as the little-endian integer, forming a
       secret scalar s.  Perform a fixed-base scalar multiplication
       [s]B.

   4.  The public key A is the encoding of the point [s]B.  First,
       encode the y-coordinate (in the range 0 <= y < p) as a little-
       endian string of 32 octets.  The most significant bit of the
       final octet is always zero.  To form the encoding of the point
       [s]B, copy the least significant bit of the x coordinate to the
       most significant bit of the final octet.  The result is the
       public key.
*)

let derive_key_pair_spec
  (ikm_len: size_t { valid_hkdf_ikm_len ikm_len })
  (ikm: Seq.lseq uint8 (v ikm_len))
  (lbl_len: size_t { valid_hkdf_lbl_len lbl_len })
  (lbl: Seq.lseq uint8 (v lbl_len))
: GTot (Seq.lseq pub_uint8 32 & Seq.lseq uint8 32)
= let alg = SHA2_256 in
  (* Derive private key from `ikm` and `lbl` using HKDF *)
  (* Step 1. extract a `prk` (Pseudo Random Key) from an empty `salt` of `hashLen` and `ikm` *)
  let salt = Seq.create (v (hash_len alg)) (u8 0x00) in
  let prk  = Spec.Agile.HKDF.extract
               (* alg *) alg
               (* salt*) salt
               (* ikm *) ikm in
  (* Step 2. expand `prk` and `lbl` to a `okm` (Output Keying Material) *)
  let private_key = Spec.Agile.HKDF.expand
                       (* alg *) alg
                       (* prk *) prk
                       (* info*) lbl
                       (* len *) (hash_length alg) in

  (* Derive public key from private key using Ed25519 (FIXME: Or Curve25519?) *)
  let public_key = declassify_secret_bytes (Spec.Ed25519.secret_to_public private_key) in

(* return *) (public_key, private_key)

#push-options "--z3rlimit 32"
let derive_key_pair
  (public_key : B.lbuffer pub_uint8 32)                 // Out
  (private_key: B.lbuffer uint8 32)                     // Out
                    (* NOTE Not using lbuffer here because lbuffer doesn't accept null *)
  (ikm_len: size_t) (ikm: B.buffer uint8 {B.length ikm == v ikm_len})  // In: Initial Data for derivation
  (lbl_len: size_t) (lbl: B.buffer uint8 {B.length lbl == v lbl_len})  // In: Label for derivation
: HST.Stack unit
  (requires fun h -> let alg = SHA2_256 in
    (* Separation Logic Properties *)
    B.live h ikm /\ B.live h lbl /\ B.live h public_key /\ B.live h private_key /\
    B.all_disjoint [B.loc_buffer ikm;
                    B.loc_buffer lbl;
                    B.loc_buffer public_key;
                    B.loc_buffer private_key] /\

    (* for Hacl.HKDF.extract_st *)
    v ikm_len + block_length alg < pow2 32 /\
    (* for Spec.Agile.HKDF.extract *)
    v ikm_len + block_length alg <= max_input_length alg /\
    (* for Hacl.HKDF.expand_st *)
    hash_length alg + v lbl_len + 1 + block_length alg < pow2 32 /\
    (* for Spec.Aigle.HKDF.expand *)
    hash_length alg + v lbl_len + 1 + block_length alg < max_input_length alg)
  (ensures  fun h0 _ h1 -> let alg = SHA2_256 in
    B.(modifies ((loc_buffer public_key) `loc_union` (loc_buffer private_key)) h0 h1) /\
   (let pub_seq, priv_seq = derive_key_pair_spec ikm_len (B.as_seq h0 ikm) lbl_len (B.as_seq h0 lbl) in
    B.as_seq h1 public_key == pub_seq /\ B.as_seq h1 private_key == priv_seq ))
= HST.push_frame ();

  (* NOTE:  Using SHA2_256 because Curve25519/Ed25519 requires a 32-bit private key *)
  let alg = SHA2_256 in

  (* Using an empty (0x00) buffer of hashLen as salt. *)
  let salt: b:B.lbuffer uint8 32 {Spec.Agile.HMAC.keysized alg (B.length b)} = B.alloca (u8 0x00) (hash_len alg) in

  (* Derive private key from `ikm` and `lbl` using HKDF *)
  (* Step 1. extract a `prk` (Pseudo Random Key) from an empty `salt` of `hashLen` and `ikm` *)
  let prk : b:B.lbuffer uint8 32 {B.length b == hash_length alg} = B.alloca (u8 0x00) (hash_len alg) in
  HKDF.extract_sha2_256
    prk                 // out: Pseudo Random Key
    salt (hash_len alg) // in : (optional) Salt
    ikm  ikm_len;       // in : Input Keying Material

  (* Step 2. expand `prk` and `lbl` to a `okm` (Output Keying Material) *)
  (**)assert_norm (Spec.Agile.HMAC.keysized alg (hash_length alg));
  HKDF.expand_sha2_256
    private_key        // out: Output Keying Material
    prk (hash_len alg) // in : Pseudo Random Key
    lbl lbl_len        // in : (optional) Info
    (hash_len alg);    // in : okm len

  (* Derive public key from private key using Ed25519 (FIXME: Or Curve25519?) *)
  let secret_public_key: B.lbuffer uint8 32 = B.alloca (u8 0) 32ul in
  Ed25519.secret_to_public
    secret_public_key   // out: public
    private_key; // in : secret

  declassify_secret_buffer
    (* len *) 32ul
    (* src *) secret_public_key
    (* dst *) public_key;
  HST.pop_frame ()
#pop-options

(* DeviceID Derivation *)
#push-options "--z3rlimit 32 --initial_fuel 2 --initial_ifuel 2"
let derive_DeviceID_spec
  (cdi: lbytes_sec 32)
  (riot_label_DeviceID_len: size_t {valid_hkdf_lbl_len riot_label_DeviceID_len})
  (riot_label_DeviceID: lbytes_sec (v riot_label_DeviceID_len))
: GTot (lbytes_pub 32 & lbytes_sec 32)
= let cdigest = Spec.Agile.Hash.hash alg cdi in
  derive_key_pair_spec
    (* ikm *) 32ul cdigest
    (* lbl *) riot_label_DeviceID_len riot_label_DeviceID
#pop-options

(* ZT: failed to use StackInline *)
#restart-solver
#push-options "--query_stats --z3rlimit 32 --fuel 2 --ifuel 2"
let derive_DeviceID
  (deviceID_pub: B.lbuffer pub_uint8 32)
  (deviceID_priv: B.lbuffer uint8 32)
  // (cdi_len: hashable_len)
  (cdi: B.lbuffer uint8 32)
  (riot_label_DeviceID_len: size_t {valid_hkdf_lbl_len riot_label_DeviceID_len})
  (riot_label_DeviceID: B.lbuffer uint8 (v riot_label_DeviceID_len))
: HST.Stack (unit)
  (requires fun h ->
    B.(all_live h [buf deviceID_pub;
                   buf deviceID_priv;
                   buf cdi;
                   buf riot_label_DeviceID]) /\
    B.(all_disjoint [loc_buffer deviceID_pub;
                     loc_buffer deviceID_priv;
                     loc_buffer cdi;
                     loc_buffer riot_label_DeviceID]))
  (ensures fun h0 _ h1 ->
    B.(modifies (loc_buffer deviceID_pub `loc_union` loc_buffer deviceID_priv) h0 h1) /\
    ((B.as_seq h1 deviceID_pub <: lbytes_pub 32), (B.as_seq h1 deviceID_priv <: lbytes_sec 32)) ==
    derive_DeviceID_spec (B.as_seq h1 cdi) riot_label_DeviceID_len (B.as_seq h1 riot_label_DeviceID)
   )
= HST.push_frame ();
  let cDigest = B.alloca (u8 0) 32ul in
  riot_hash alg
    cdi 32ul
    cDigest;
  derive_key_pair
    deviceID_pub
    deviceID_priv
    32ul cDigest
    riot_label_DeviceID_len riot_label_DeviceID;
  HST.pop_frame ()
#pop-options

(* AliasKey Derivation *)
#push-options "--query_stats --z3rlimit 32 --fuel 2 --ifuel 2"
let derive_AliasKey_spec
  (cdi: lbytes_sec 32)
  (fwid: lbytes_sec 32)
  (riot_label_AliasKey_len: size_t {valid_hkdf_lbl_len riot_label_AliasKey_len})
  (riot_label_AliasKey: lbytes_sec (v riot_label_AliasKey_len))
: GTot (lbytes_pub 32 & lbytes_sec 32)
= let cdigest = Spec.Agile.Hash.hash alg cdi in
  let adigest = Spec.Agile.HMAC.hmac alg cdigest fwid in
  derive_key_pair_spec
    (* ikm *) 32ul adigest
    (* lbl *) riot_label_AliasKey_len riot_label_AliasKey
#pop-options

#push-options "--query_stats --z3rlimit 32 --fuel 2 --ifuel 2"
let derive_AliasKey
  (aliasKey_pub: B.lbuffer pub_uint8 32)
  (aliasKey_priv: B.lbuffer uint8 32)
  // (cdi_len: hashable_len)
  (cdi: B.lbuffer uint8 32)
  (fwid: B.lbuffer uint8 32)
  (riot_label_AliasKey_len: size_t {valid_hkdf_lbl_len riot_label_AliasKey_len})
  (riot_label_AliasKey: B.lbuffer uint8 (v riot_label_AliasKey_len))
: HST.Stack (unit)
  (requires fun h ->
    B.(all_live h [buf aliasKey_pub;
                   buf aliasKey_priv;
                   buf cdi;
                   buf fwid;
                   buf riot_label_AliasKey]) /\
    B.(all_disjoint [loc_buffer aliasKey_pub;
                     loc_buffer aliasKey_priv;
                     loc_buffer cdi;
                     loc_buffer fwid;
                     loc_buffer riot_label_AliasKey]))
  (ensures fun h0 _ h1 ->
    B.(modifies (loc_buffer aliasKey_pub `loc_union` loc_buffer aliasKey_priv) h0 h1) /\
    ((B.as_seq h1 aliasKey_pub <: lbytes_pub 32),
     (B.as_seq h1 aliasKey_priv <: lbytes_sec 32)) == derive_AliasKey_spec
                                                        (B.as_seq h1 cdi)
                                                        (B.as_seq h1 fwid)
                                                        riot_label_AliasKey_len
                                                        (B.as_seq h1 riot_label_AliasKey) /\
    True
    )
= HST.push_frame ();
  let cDigest = B.alloca (u8 0) 32ul in
  riot_hash alg
    cdi 32ul
    cDigest;
  let aDigest = B.alloca (u8 0) 32ul in
  riot_hmac alg
    aDigest
    cDigest 32ul
    fwid    32ul;
  derive_key_pair
    aliasKey_pub
    aliasKey_priv
    32ul aDigest
    riot_label_AliasKey_len riot_label_AliasKey;
  HST.pop_frame ()
#pop-options
