/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -no-prefix Minimal.DICE ./src/Minimal.DICE.fst -skip-compilation -tmpdir ./out -I ./src -I /home/zhetao/Sources/hacl-star/specs -I /home/zhetao/Sources/hacl-star/specs/lemmas -I /home/zhetao/Sources/hacl-star/code/hash -I /home/zhetao/Sources/hacl-star/code/hkdf -I /home/zhetao/Sources/hacl-star/code/hmac -I /home/zhetao/Sources/hacl-star/code/curve25519 -I /home/zhetao/Sources/hacl-star/code/ed25519 -I /home/zhetao/Sources/hacl-star/lib -I /home/zhetao/Sources/hacl-star/providers/evercrypt -warn-error +11
  F* version: 953b2211
  KreMLin version: e324b7e6
 */

#include "FStar.h"

typedef struct Prims_list__bool_s Prims_list__bool;

typedef struct Prims_list__bool_s
{
  Prims_list__bool_tags tag;
  bool hd;
  Prims_list__bool *tl;
}
Prims_list__bool;

#define FStar_Seq_Base_MkSeq 0

typedef uint8_t FStar_Seq_Base_seq__bool_tags;

typedef Prims_list__bool *FStar_Seq_Base_seq__bool;

static Prims_list__bool *FStar_Seq_Base_cons__bool(bool x, Prims_list__bool *s)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__bool), (uint32_t)1U);
  Prims_list__bool *buf = KRML_HOST_MALLOC(sizeof (Prims_list__bool));
  buf[0U] = ((Prims_list__bool){ .tag = Prims_Cons, .hd = x, .tl = s });
  return buf;
}

static Prims_list__bool *FStar_Seq_Base_create__bool(Prims_int len, bool v)
{
  if (len == (krml_checked_int_t)0)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__bool), (uint32_t)1U);
    Prims_list__bool *buf = KRML_HOST_MALLOC(sizeof (Prims_list__bool));
    buf[0U] = ((Prims_list__bool){ .tag = Prims_Nil });
    return buf;
  }
  else
    return
      FStar_Seq_Base_cons__bool(v,
        FStar_Seq_Base_create__bool(Prims_op_Subtraction(len, (krml_checked_int_t)1), v));
}

static bool FStar_List_Tot_Base_hd__bool(Prims_list__bool *uu___0_39)
{
  if (uu___0_39->tag == Prims_Cons)
    return uu___0_39->hd;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__bool *FStar_List_Tot_Base_tail__bool(Prims_list__bool *uu___1_64)
{
  if (uu___1_64->tag == Prims_Cons)
    return uu___1_64->tl;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__bool
*(*FStar_List_Tot_Base_tl__bool)(Prims_list__bool *x0) = FStar_List_Tot_Base_tail__bool;

static bool FStar_List_Tot_Base_index__bool(Prims_list__bool *l, Prims_int i)
{
  if (i == (krml_checked_int_t)0)
    return FStar_List_Tot_Base_hd__bool(l);
  else
    return
      FStar_List_Tot_Base_index__bool(FStar_List_Tot_Base_tl__bool(l),
        Prims_op_Subtraction(i, (krml_checked_int_t)1));
}

static bool FStar_Seq_Base_index__bool(Prims_list__bool *s, Prims_int i)
{
  return FStar_List_Tot_Base_index__bool(s, i);
}

static Prims_list__bool
*FStar_List_Tot_Base_append__bool(Prims_list__bool *x, Prims_list__bool *y)
{
  if (x->tag == Prims_Nil)
    return y;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__bool *tl1 = x->tl;
    bool a = x->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__bool), (uint32_t)1U);
    Prims_list__bool *buf = KRML_HOST_MALLOC(sizeof (Prims_list__bool));
    buf[0U]
    =
      (
        (Prims_list__bool){
          .tag = Prims_Cons,
          .hd = a,
          .tl = FStar_List_Tot_Base_append__bool(tl1, y)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__bool
*FStar_Seq_Base_append__bool(Prims_list__bool *s1, Prims_list__bool *s2)
{
  return FStar_List_Tot_Base_append__bool(s1, s2);
}

static Prims_list__bool *FStar_Seq_Base_tl__bool(Prims_list__bool *s)
{
  return FStar_List_Tot_Base_tl__bool(s);
}

static bool FStar_Seq_Base_hd__bool(Prims_list__bool *s)
{
  return FStar_List_Tot_Base_hd__bool(s);
}

static Prims_list__bool
*FStar_Seq_Base_slice__bool(Prims_list__bool *s, Prims_int i, Prims_int j)
{
  if (Prims_op_GreaterThan(i, (krml_checked_int_t)0))
    return
      FStar_Seq_Base_slice__bool(FStar_Seq_Base_tl__bool(s),
        Prims_op_Subtraction(i, (krml_checked_int_t)1),
        Prims_op_Subtraction(j, (krml_checked_int_t)1));
  else if (j == (krml_checked_int_t)0)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__bool), (uint32_t)1U);
    Prims_list__bool *buf = KRML_HOST_MALLOC(sizeof (Prims_list__bool));
    buf[0U] = ((Prims_list__bool){ .tag = Prims_Nil });
    return buf;
  }
  else
    return
      FStar_Seq_Base_cons__bool(FStar_Seq_Base_hd__bool(s),
        FStar_Seq_Base_slice__bool(FStar_Seq_Base_tl__bool(s),
          i,
          Prims_op_Subtraction(j, (krml_checked_int_t)1)));
}

static Prims_list__bool
*FStar_BitVector_logand_vec(Prims_pos n, Prims_list__bool *a, Prims_list__bool *b)
{
  if (n == (krml_checked_int_t)1)
    return
      FStar_Seq_Base_create__bool((krml_checked_int_t)1,
        FStar_Seq_Base_index__bool(a,
          (krml_checked_int_t)0)
        && FStar_Seq_Base_index__bool(b, (krml_checked_int_t)0));
  else
    return
      FStar_Seq_Base_append__bool(FStar_Seq_Base_create__bool((krml_checked_int_t)1,
          FStar_Seq_Base_index__bool(a,
            (krml_checked_int_t)0)
          && FStar_Seq_Base_index__bool(b, (krml_checked_int_t)0)),
        FStar_BitVector_logand_vec(Prims_op_Subtraction(n, (krml_checked_int_t)1),
          FStar_Seq_Base_slice__bool(a, (krml_checked_int_t)1, n),
          FStar_Seq_Base_slice__bool(b, (krml_checked_int_t)1, n)));
}

static Prims_list__bool
*FStar_BitVector_logor_vec(Prims_pos n, Prims_list__bool *a, Prims_list__bool *b)
{
  if (n == (krml_checked_int_t)1)
    return
      FStar_Seq_Base_create__bool((krml_checked_int_t)1,
        FStar_Seq_Base_index__bool(a,
          (krml_checked_int_t)0)
        || FStar_Seq_Base_index__bool(b, (krml_checked_int_t)0));
  else
    return
      FStar_Seq_Base_append__bool(FStar_Seq_Base_create__bool((krml_checked_int_t)1,
          FStar_Seq_Base_index__bool(a,
            (krml_checked_int_t)0)
          || FStar_Seq_Base_index__bool(b, (krml_checked_int_t)0)),
        FStar_BitVector_logor_vec(Prims_op_Subtraction(n, (krml_checked_int_t)1),
          FStar_Seq_Base_slice__bool(a, (krml_checked_int_t)1, n),
          FStar_Seq_Base_slice__bool(b, (krml_checked_int_t)1, n)));
}

static Prims_list__bool *FStar_Seq_Base_empty__bool()
{
  KRML_CHECK_SIZE(sizeof (Prims_list__bool), (uint32_t)1U);
  Prims_list__bool *buf = KRML_HOST_MALLOC(sizeof (Prims_list__bool));
  buf[0U] = ((Prims_list__bool){ .tag = Prims_Nil });
  return buf;
}

static Prims_list__bool *FStar_UInt_to_vec(Prims_int n, Prims_int num)
{
  if (n == (krml_checked_int_t)0)
    return FStar_Seq_Base_empty__bool();
  else
    return
      FStar_Seq_Base_append__bool(FStar_UInt_to_vec(Prims_op_Subtraction(n, (krml_checked_int_t)1),
          Prims_op_Division(num, (krml_checked_int_t)2)),
        FStar_Seq_Base_create__bool((krml_checked_int_t)1,
          Prims_op_Modulus(num, (krml_checked_int_t)2) == (krml_checked_int_t)1));
}

static Prims_int FStar_UInt_from_vec(Prims_int n, Prims_list__bool *vec)
{
  if (n == (krml_checked_int_t)0)
    return (krml_checked_int_t)0;
  else
  {
    krml_checked_int_t ite;
    if (FStar_Seq_Base_index__bool(vec, Prims_op_Subtraction(n, (krml_checked_int_t)1)))
      ite = (krml_checked_int_t)1;
    else
      ite = (krml_checked_int_t)0;
    return
      Prims_op_Addition(Prims_op_Multiply((krml_checked_int_t)2,
          FStar_UInt_from_vec(Prims_op_Subtraction(n, (krml_checked_int_t)1),
            FStar_Seq_Base_slice__bool(vec,
              (krml_checked_int_t)0,
              Prims_op_Subtraction(n, (krml_checked_int_t)1)))),
        ite);
  }
}

Prims_int FStar_UInt_logand(Prims_pos n, Prims_int a, Prims_int b)
{
  return
    FStar_UInt_from_vec(n,
      FStar_BitVector_logand_vec(n, FStar_UInt_to_vec(n, a), FStar_UInt_to_vec(n, b)));
}

Prims_int FStar_UInt_logor(Prims_pos n, Prims_int a, Prims_int b)
{
  return
    FStar_UInt_from_vec(n,
      FStar_BitVector_logor_vec(n, FStar_UInt_to_vec(n, a), FStar_UInt_to_vec(n, b)));
}

static Prims_int FStar_Int_max_int(Prims_pos n1)
{
  return
    Prims_op_Subtraction(Prims_pow2(Prims_op_Subtraction(n1, (krml_checked_int_t)1)),
      (krml_checked_int_t)1);
}

static Prims_int FStar_Int_op_Slash(Prims_int a, Prims_int b)
{
  if
  (
    Prims_op_GreaterThanOrEqual(a,
      (krml_checked_int_t)0)
    && Prims_op_LessThan(b, (krml_checked_int_t)0)
    ||
      Prims_op_LessThan(a,
        (krml_checked_int_t)0)
      && Prims_op_GreaterThanOrEqual(b, (krml_checked_int_t)0)
  )
    return Prims_op_Minus(Prims_op_Division(Prims_abs(a), Prims_abs(b)));
  else
    return Prims_op_Division(Prims_abs(a), Prims_abs(b));
}

Prims_int FStar_Int_op_At_Percent(Prims_int v1, Prims_int p)
{
  Prims_int m = Prims_op_Modulus(v1, p);
  if (Prims_op_GreaterThanOrEqual(m, FStar_Int_op_Slash(p, (krml_checked_int_t)2)))
    return Prims_op_Subtraction(m, p);
  else
    return m;
}

static Prims_int FStar_Int_to_uint(Prims_pos n1, Prims_int x)
{
  if (Prims_op_LessThanOrEqual((krml_checked_int_t)0, x))
    return x;
  else
    return Prims_op_Addition(x, Prims_pow2(n1));
}

static Prims_list__bool *FStar_Int_to_vec(Prims_pos n1, Prims_int num)
{
  return FStar_UInt_to_vec(n1, FStar_Int_to_uint(n1, num));
}

static Prims_int FStar_Int_from_vec(Prims_pos n1, Prims_list__bool *vec)
{
  Prims_int x = FStar_UInt_from_vec(n1, vec);
  if (Prims_op_LessThan(FStar_Int_max_int(n1), x))
    return Prims_op_Subtraction(x, Prims_pow2(n1));
  else
    return x;
}

Prims_int FStar_Int_logand(Prims_pos n1, Prims_int a, Prims_int b)
{
  return
    FStar_Int_from_vec(n1,
      FStar_BitVector_logand_vec(n1, FStar_Int_to_vec(n1, a), FStar_Int_to_vec(n1, b)));
}

Prims_int FStar_Int_logor(Prims_pos n1, Prims_int a, Prims_int b)
{
  return
    FStar_Int_from_vec(n1,
      FStar_BitVector_logor_vec(n1, FStar_Int_to_vec(n1, a), FStar_Int_to_vec(n1, b)));
}

